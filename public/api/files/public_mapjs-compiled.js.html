<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/mapjs-compiled.js - MindMup</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="https://mindmup.github.com/logo_64.png" title="MindMup"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 20141124</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ActivityLog.html">ActivityLog</a></li>
                                <li><a href="../classes/GoldApi.html">GoldApi</a></li>
                                <li><a href="../classes/GoldLicenseManager.html">GoldLicenseManager</a></li>
                                <li><a href="../classes/JsonStorage.html">JsonStorage</a></li>
                                <li><a href="../classes/LayoutExportController.html">LayoutExportController</a></li>
                                <li><a href="../classes/S3Api.html">S3Api</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/MM.html">MM</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: public/mapjs-compiled.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        var MAPJS = MAPJS || {};
                        /*global console*/
                        var observable = function (base) {
                        	&#x27;use strict&#x27;;
                        	var listeners = [];
                        	base.addEventListener = function (types, listener, priority) {
                        		types.split(&#x27; &#x27;).forEach(function (type) {
                        			if (type) {
                        				listeners.push({
                        					type: type,
                        					listener: listener,
                        					priority: priority || 0
                        				});
                        			}
                        		});
                        	};
                        	base.listeners = function (type) {
                        		return listeners.filter(function (listenerDetails) {
                        			return listenerDetails.type === type;
                        		}).map(function (listenerDetails) {
                        			return listenerDetails.listener;
                        		});
                        	};
                        	base.removeEventListener = function (type, listener) {
                        		listeners = listeners.filter(function (details) {
                        			return details.listener !== listener;
                        		});
                        	};
                        	base.dispatchEvent = function (type) {
                        		var args = Array.prototype.slice.call(arguments, 1);
                        		listeners
                        			.filter(function (listenerDetails) {
                        				return listenerDetails.type === type;
                        			})
                        			.sort(function (firstListenerDetails, secondListenerDetails) {
                        				return secondListenerDetails.priority - firstListenerDetails.priority;
                        			})
                        			.some(function (listenerDetails) {
                        				try {
                        					return listenerDetails.listener.apply(undefined, args) === false;
                        				} catch (e) {
                        					console.log(&#x27;dispatchEvent failed&#x27;, e, listenerDetails);
                        				}
                        
                        			});
                        	};
                        	return base;
                        };
                        /*global MAPJS */
                        MAPJS.URLHelper = {
                        	urlPattern: /(https?:\/\/|www\.)[\w-]+(\.[\w-]+)+([\w.,!@?^=%&amp;amp;:\/~+#-]*[\w!@?^=%&amp;amp;\/~+#-])?/i,
                        	containsLink : function (text) {
                        		&#x27;use strict&#x27;;
                        		return MAPJS.URLHelper.urlPattern.test(text);
                        	},
                        	getLink : function (text) {
                        		&#x27;use strict&#x27;;
                        		var url = text.match(MAPJS.URLHelper.urlPattern);
                        		if (url &amp;&amp; url[0]) {
                        			url = url[0];
                        			if (!/https?:\/\//i.test(url)) {
                        				url = &#x27;http://&#x27; + url;
                        			}
                        		}
                        		return url;
                        	},
                        	stripLink : function (text) {
                        		&#x27;use strict&#x27;;
                        		return text.replace(MAPJS.URLHelper.urlPattern, &#x27;&#x27;);
                        	}
                        };
                        /*jslint eqeq: true, forin: true, nomen: true*/
                        /*jshint unused:false, loopfunc:true */
                        /*global _, MAPJS, observable*/
                        MAPJS.content = function (contentAggregate, sessionKey) {
                        	&#x27;use strict&#x27;;
                        	var cachedId,
                        		invalidateIdCache = function () {
                        			cachedId = undefined;
                        		},
                        		maxId = function maxId(idea) {
                        			idea = idea || contentAggregate;
                        			if (!idea.ideas) {
                        				return parseInt(idea.id, 10) || 0;
                        			}
                        			return _.reduce(
                        				idea.ideas,
                        				function (result, subidea) {
                        					return Math.max(result, maxId(subidea));
                        				},
                        				parseInt(idea.id, 10) || 0
                        			);
                        		},
                        		nextId = function nextId(originSession) {
                        			originSession = originSession || sessionKey;
                        			if (!cachedId) {
                        				cachedId =  maxId();
                        			}
                        			cachedId += 1;
                        			if (originSession) {
                        				return cachedId + &#x27;.&#x27; + originSession;
                        			}
                        			return cachedId;
                        		},
                        		init = function (contentIdea, originSession) {
                        			if (!contentIdea.id) {
                        				contentIdea.id = nextId(originSession);
                        			} else {
                        				invalidateIdCache();
                        			}
                        			if (contentIdea.ideas) {
                        				_.each(contentIdea.ideas, function (value, key) {
                        					contentIdea.ideas[parseFloat(key)] = init(value, originSession);
                        				});
                        			}
                        			if (!contentIdea.title) {
                        				contentIdea.title = &#x27;&#x27;;
                        			}
                        			contentIdea.containsDirectChild = contentIdea.findChildRankById = function (childIdeaId) {
                        				return parseFloat(
                        					_.reduce(
                        						contentIdea.ideas,
                        						function (res, value, key) {
                        							return value.id == childIdeaId ? key : res;
                        						},
                        						undefined
                        					)
                        				);
                        			};
                        			contentIdea.findSubIdeaById = function (childIdeaId) {
                        				var myChild = _.find(contentIdea.ideas, function (idea) {
                        					return idea.id == childIdeaId;
                        				});
                        				return myChild || _.reduce(contentIdea.ideas, function (result, idea) {
                        					return result || idea.findSubIdeaById(childIdeaId);
                        				}, undefined);
                        			};
                        			contentIdea.find = function (predicate) {
                        				var current = predicate(contentIdea) ? [_.pick(contentIdea, &#x27;id&#x27;, &#x27;title&#x27;)] : [];
                        				if (_.size(contentIdea.ideas) === 0) {
                        					return current;
                        				}
                        				return _.reduce(contentIdea.ideas, function (result, idea) {
                        					return _.union(result, idea.find(predicate));
                        				}, current);
                        			};
                        			contentIdea.getAttr = function (name) {
                        				if (contentIdea.attr &amp;&amp; contentIdea.attr[name]) {
                        					return _.clone(contentIdea.attr[name]);
                        				}
                        				return false;
                        			};
                        			contentIdea.sortedSubIdeas = function () {
                        				if (!contentIdea.ideas) {
                        					return [];
                        				}
                        				var result = [],
                        					childKeys = _.groupBy(_.map(_.keys(contentIdea.ideas), parseFloat), function (key) { return key &gt; 0; }),
                        					sortedChildKeys = _.sortBy(childKeys[true], Math.abs).concat(_.sortBy(childKeys[false], Math.abs));
                        				_.each(sortedChildKeys, function (key) {
                        					result.push(contentIdea.ideas[key]);
                        				});
                        				return result;
                        			};
                        			contentIdea.traverse = function (iterator, postOrder) {
                        				if (!postOrder) {
                        					iterator(contentIdea);
                        				}
                        				_.each(contentIdea.sortedSubIdeas(), function (subIdea) {
                        					subIdea.traverse(iterator, postOrder);
                        				});
                        				if (postOrder) {
                        					iterator(contentIdea);
                        				}
                        			};
                        			return contentIdea;
                        		},
                        		maxKey = function (kvMap, sign) {
                        			sign = sign || 1;
                        			if (_.size(kvMap) === 0) {
                        				return 0;
                        			}
                        			var currentKeys = _.keys(kvMap);
                        			currentKeys.push(0); /* ensure at least 0 is there for negative ranks */
                        			return _.max(_.map(currentKeys, parseFloat), function (x) {
                        				return x * sign;
                        			});
                        		},
                        		nextChildRank = function (parentIdea) {
                        			var newRank, counts, childRankSign = 1;
                        			if (parentIdea.id == contentAggregate.id) {
                        				counts = _.countBy(parentIdea.ideas, function (v, k) {
                        					return k &lt; 0;
                        				});
                        				if ((counts[&#x27;true&#x27;] || 0) &lt; counts[&#x27;false&#x27;]) {
                        					childRankSign = -1;
                        				}
                        			}
                        			newRank = maxKey(parentIdea.ideas, childRankSign) + childRankSign;
                        			return newRank;
                        		},
                        		appendSubIdea = function (parentIdea, subIdea) {
                        			var rank;
                        			parentIdea.ideas = parentIdea.ideas || {};
                        			rank = nextChildRank(parentIdea);
                        			parentIdea.ideas[rank] = subIdea;
                        			return rank;
                        		},
                        		findIdeaById = function (ideaId) {
                        			return contentAggregate.id == ideaId ? contentAggregate : contentAggregate.findSubIdeaById(ideaId);
                        		},
                        		sameSideSiblingRanks = function (parentIdea, ideaRank) {
                        			return _(_.map(_.keys(parentIdea.ideas), parseFloat)).reject(function (k) {return k * ideaRank &lt; 0; });
                        		},
                        		sign = function (number) {
                        			/* intentionally not returning 0 case, to help with split sorting into 2 groups */
                        			return number &lt; 0 ? -1 : 1;
                        		},
                        		eventStacks = {},
                        		redoStacks = {},
                        		isRedoInProgress = false,
                        		batches = {},
                        		notifyChange = function (method, args, originSession) {
                        			if (originSession) {
                        				contentAggregate.dispatchEvent(&#x27;changed&#x27;, method, args, originSession);
                        			} else {
                        				contentAggregate.dispatchEvent(&#x27;changed&#x27;, method, args);
                        			}
                        		},
                        		appendChange = function (method, args, undofunc, originSession) {
                        			var prev;
                        			if (method === &#x27;batch&#x27; || batches[originSession] || !eventStacks || !eventStacks[originSession] || eventStacks[originSession].length === 0) {
                        				logChange(method, args, undofunc, originSession);
                        				return;
                        			} else {
                        				prev = eventStacks[originSession].pop();
                        				if (prev.eventMethod === &#x27;batch&#x27;) {
                        					eventStacks[originSession].push({
                        						eventMethod: &#x27;batch&#x27;,
                        						eventArgs: prev.eventArgs.concat([[method].concat(args)]),
                        						undoFunction: function () {
                        							undofunc();
                        							prev.undoFunction();
                        						}
                        					});
                        				} else {
                        					eventStacks[originSession].push({
                        						eventMethod: &#x27;batch&#x27;,
                        						eventArgs: [[prev.eventMethod].concat(prev.eventArgs)].concat([[method].concat(args)]),
                        						undoFunction: function () {
                        							undofunc();
                        							prev.undoFunction();
                        						}
                        					});
                        				}
                        			}
                        			if (isRedoInProgress) {
                        				contentAggregate.dispatchEvent(&#x27;changed&#x27;, &#x27;redo&#x27;, undefined, originSession);
                        			} else {
                        				notifyChange(method, args, originSession);
                        				redoStacks[originSession] = [];
                        			}
                        		},
                        		logChange = function (method, args, undofunc, originSession) {
                        			var event = {eventMethod: method, eventArgs: args, undoFunction: undofunc};
                        			if (batches[originSession]) {
                        				batches[originSession].push(event);
                        				return;
                        			}
                        			if (!eventStacks[originSession]) {
                        				eventStacks[originSession] = [];
                        			}
                        			eventStacks[originSession].push(event);
                        
                        			if (isRedoInProgress) {
                        				contentAggregate.dispatchEvent(&#x27;changed&#x27;, &#x27;redo&#x27;, undefined, originSession);
                        			} else {
                        				notifyChange(method, args, originSession);
                        				redoStacks[originSession] = [];
                        			}
                        		},
                        		reorderChild = function (parentIdea, newRank, oldRank) {
                        			parentIdea.ideas[newRank] = parentIdea.ideas[oldRank];
                        			delete parentIdea.ideas[oldRank];
                        		},
                        		upgrade = function (idea) {
                        			if (idea.style) {
                        				idea.attr = {};
                        				var collapsed = idea.style.collapsed;
                        				delete idea.style.collapsed;
                        				idea.attr.style = idea.style;
                        				if (collapsed) {
                        					idea.attr.collapsed = collapsed;
                        				}
                        				delete idea.style;
                        			}
                        			if (idea.ideas) {
                        				_.each(idea.ideas, upgrade);
                        			}
                        		},
                        		sessionFromId = function (id) {
                        			var dotIndex = String(id).indexOf(&#x27;.&#x27;);
                        			return dotIndex &gt; 0 &amp;&amp; id.substr(dotIndex + 1);
                        		},
                        		commandProcessors = {},
                        		configuration = {},
                        		uniqueResourcePostfix = &#x27;/xxxxxxxx-yxxx-yxxx-yxxx-xxxxxxxxxxxx/&#x27;.replace(/[xy]/g, function (c) {
                        			/*jshint bitwise: false*/
                        			var r = Math.random() * 16 | 0, v = c === &#x27;x&#x27; ? r : (r&amp;0x3|0x8);
                        			return v.toString(16);
                        		}) + (sessionKey || &#x27;&#x27;);
                        	contentAggregate.setConfiguration = function (config) {
                        		configuration = config || {};
                        	};
                        	contentAggregate.getSessionKey = function () {
                        		return sessionKey;
                        	};
                        	contentAggregate.nextSiblingId = function (subIdeaId) {
                        		var parentIdea = contentAggregate.findParent(subIdeaId),
                        			currentRank,
                        			candidateSiblingRanks,
                        			siblingsAfter;
                        		if (!parentIdea) { return false; }
                        		currentRank = parentIdea.findChildRankById(subIdeaId);
                        		candidateSiblingRanks = sameSideSiblingRanks(parentIdea, currentRank);
                        		siblingsAfter = _.reject(candidateSiblingRanks, function (k) { return Math.abs(k) &lt;= Math.abs(currentRank); });
                        		if (siblingsAfter.length === 0) { return false; }
                        		return parentIdea.ideas[_.min(siblingsAfter, Math.abs)].id;
                        	};
                        	contentAggregate.sameSideSiblingIds = function (subIdeaId) {
                        		var parentIdea = contentAggregate.findParent(subIdeaId),
                        			currentRank = parentIdea.findChildRankById(subIdeaId);
                        		return _.without(_.map(_.pick(parentIdea.ideas, sameSideSiblingRanks(parentIdea, currentRank)), function (i) { return i.id; }), subIdeaId);
                        	};
                        	contentAggregate.getAttrById = function (ideaId, attrName) {
                        		var idea = findIdeaById(ideaId);
                        		return idea &amp;&amp; idea.getAttr(attrName);
                        	};
                        	contentAggregate.previousSiblingId = function (subIdeaId) {
                        		var parentIdea = contentAggregate.findParent(subIdeaId),
                        			currentRank,
                        			candidateSiblingRanks,
                        			siblingsBefore;
                        		if (!parentIdea) { return false; }
                        		currentRank = parentIdea.findChildRankById(subIdeaId);
                        		candidateSiblingRanks = sameSideSiblingRanks(parentIdea, currentRank);
                        		siblingsBefore = _.reject(candidateSiblingRanks, function (k) { return Math.abs(k) &gt;= Math.abs(currentRank); });
                        		if (siblingsBefore.length === 0) { return false; }
                        		return parentIdea.ideas[_.max(siblingsBefore, Math.abs)].id;
                        	};
                        	contentAggregate.clone = function (subIdeaId) {
                        		var toClone = (subIdeaId &amp;&amp; subIdeaId != contentAggregate.id &amp;&amp; contentAggregate.findSubIdeaById(subIdeaId)) || contentAggregate;
                        		return JSON.parse(JSON.stringify(toClone));
                        	};
                        	contentAggregate.cloneMultiple = function (subIdeaIdArray) {
                        		return _.map(subIdeaIdArray, contentAggregate.clone);
                        	};
                        	contentAggregate.calculatePath = function (ideaId, currentPath, potentialParent) {
                        		if (contentAggregate.id == ideaId) {
                        			return [];
                        		}
                        		currentPath = currentPath || [contentAggregate];
                        		potentialParent = potentialParent || contentAggregate;
                        		if (potentialParent.containsDirectChild(ideaId)) {
                        			return currentPath;
                        		}
                        		return _.reduce(
                        			potentialParent.ideas,
                        			function (result, child) {
                        				return result || contentAggregate.calculatePath(ideaId, [child].concat(currentPath), child);
                        			},
                        			false
                        		);
                        	};
                        	contentAggregate.getSubTreeIds = function (rootIdeaId) {
                        		var result = [],
                        			collectIds = function (idea) {
                        				if (_.isEmpty(idea.ideas)) {
                        					return [];
                        				}
                        				_.each(idea.sortedSubIdeas(), function (child) {
                        					collectIds(child);
                        					result.push(child.id);
                        				});
                        			};
                        		collectIds(contentAggregate.findSubIdeaById(rootIdeaId) || contentAggregate);
                        		return result;
                        	};
                        	contentAggregate.findParent = function (subIdeaId, parentIdea) {
                        		parentIdea = parentIdea || contentAggregate;
                        		if (parentIdea.containsDirectChild(subIdeaId)) {
                        			return parentIdea;
                        		}
                        		return _.reduce(
                        			parentIdea.ideas,
                        			function (result, child) {
                        				return result || contentAggregate.findParent(subIdeaId, child);
                        			},
                        			false
                        		);
                        	};
                        
                        	/**** aggregate command processing methods ****/
                        	contentAggregate.startBatch = function (originSession) {
                        		var activeSession = originSession || sessionKey;
                        		contentAggregate.endBatch(originSession);
                        		batches[activeSession] = [];
                        	};
                        	contentAggregate.endBatch = function (originSession) {
                        		var activeSession = originSession || sessionKey,
                        			inBatch = batches[activeSession],
                        			batchArgs,
                        			batchUndoFunctions,
                        			undo;
                        		batches[activeSession] = undefined;
                        		if (_.isEmpty(inBatch)) {
                        			return;
                        		}
                        		if (_.size(inBatch) === 1) {
                        			logChange(inBatch[0].eventMethod, inBatch[0].eventArgs, inBatch[0].undoFunction, activeSession);
                        		} else {
                        			batchArgs = _.map(inBatch, function (event) {
                        				return [event.eventMethod].concat(event.eventArgs);
                        			});
                        			batchUndoFunctions = _.sortBy(
                        				_.map(inBatch, function (event) { return event.undoFunction; }),
                        				function (f, idx) { return -1 * idx; }
                        			);
                        			undo = function () {
                        				_.each(batchUndoFunctions, function (eventUndo) {
                        					eventUndo();
                        				});
                        			};
                        			logChange(&#x27;batch&#x27;, batchArgs, undo, activeSession);
                        		}
                        	};
                        	contentAggregate.execCommand = function (cmd, args, originSession) {
                        		if (!commandProcessors[cmd]) {
                        			return false;
                        		}
                        		return commandProcessors[cmd].apply(contentAggregate, [originSession || sessionKey].concat(_.toArray(args)));
                        	};
                        
                        	contentAggregate.batch = function (batchOp) {
                        		contentAggregate.startBatch();
                        		try {
                        			batchOp();
                        		}
                        		finally {
                        			contentAggregate.endBatch();
                        		}
                        	};
                        
                        	commandProcessors.batch = function (originSession) {
                        		contentAggregate.startBatch(originSession);
                        		try {
                        			_.each(_.toArray(arguments).slice(1), function (event) {
                        				contentAggregate.execCommand(event[0], event.slice(1), originSession);
                        			});
                        		}
                        		finally {
                        			contentAggregate.endBatch(originSession);
                        		}
                        	};
                        	contentAggregate.pasteMultiple = function (parentIdeaId, jsonArrayToPaste) {
                        		contentAggregate.startBatch();
                        		var results = _.map(jsonArrayToPaste, function (json) {
                        			return contentAggregate.paste(parentIdeaId, json);
                        		});
                        		contentAggregate.endBatch();
                        		return results;
                        	};
                        
                        	contentAggregate.paste = function (parentIdeaId, jsonToPaste, initialId) {
                        		return contentAggregate.execCommand(&#x27;paste&#x27;, arguments);
                        	};
                        	commandProcessors.paste = function (originSession, parentIdeaId, jsonToPaste, initialId) {
                        		var pasteParent = (parentIdeaId == contentAggregate.id) ?  contentAggregate : contentAggregate.findSubIdeaById(parentIdeaId),
                        			cleanUp = function (json) {
                        				var result =  _.omit(json, &#x27;ideas&#x27;, &#x27;id&#x27;, &#x27;attr&#x27;), index = 1, childKeys, sortedChildKeys;
                        				result.attr = _.omit(json.attr, configuration.nonClonedAttributes);
                        				if (_.isEmpty(result.attr)) {
                        					delete result.attr;
                        				}
                        				if (json.ideas) {
                        					childKeys = _.groupBy(_.map(_.keys(json.ideas), parseFloat), function (key) { return key &gt; 0; });
                        					sortedChildKeys = _.sortBy(childKeys[true], Math.abs).concat(_.sortBy(childKeys[false], Math.abs));
                        					result.ideas = {};
                        					_.each(sortedChildKeys, function (key) {
                        						result.ideas[index++] = cleanUp(json.ideas[key]);
                        					});
                        				}
                        				return result;
                        			},
                        			newIdea,
                        			newRank,
                        			oldPosition;
                        		if (initialId) {
                        			cachedId = parseInt(initialId, 10) - 1;
                        		}
                        		newIdea =  jsonToPaste &amp;&amp; (jsonToPaste.title || jsonToPaste.attr) &amp;&amp; init(cleanUp(jsonToPaste), sessionFromId(initialId));
                        		if (!pasteParent || !newIdea) {
                        			return false;
                        		}
                        		newRank = appendSubIdea(pasteParent, newIdea);
                        		if (initialId) {
                        			invalidateIdCache();
                        		}
                        		updateAttr(newIdea, &#x27;position&#x27;);
                        		logChange(&#x27;paste&#x27;, [parentIdeaId, jsonToPaste, newIdea.id], function () {
                        			delete pasteParent.ideas[newRank];
                        		}, originSession);
                        		return newIdea.id;
                        	};
                        	contentAggregate.flip = function (ideaId) {
                        		return contentAggregate.execCommand(&#x27;flip&#x27;, arguments);
                        	};
                        	commandProcessors.flip = function (originSession, ideaId) {
                        		var newRank, maxRank, currentRank = contentAggregate.findChildRankById(ideaId);
                        		if (!currentRank) {
                        			return false;
                        		}
                        		maxRank = maxKey(contentAggregate.ideas, -1 * sign(currentRank));
                        		newRank = maxRank - 10 * sign(currentRank);
                        		reorderChild(contentAggregate, newRank, currentRank);
                        		logChange(&#x27;flip&#x27;, [ideaId], function () {
                        			reorderChild(contentAggregate, currentRank, newRank);
                        		}, originSession);
                        		return true;
                        	};
                        	contentAggregate.initialiseTitle = function (ideaId, title) {
                        		return contentAggregate.execCommand(&#x27;initialiseTitle&#x27;, arguments);
                        	};
                        	commandProcessors.initialiseTitle = function (originSession, ideaId, title) {
                        		var idea = findIdeaById(ideaId), originalTitle;
                        		if (!idea) {
                        			return false;
                        		}
                        		originalTitle = idea.title;
                        		if (originalTitle == title) {
                        			return false;
                        		}
                        		idea.title = title;
                        		appendChange(&#x27;initialiseTitle&#x27;, [ideaId, title], function () {
                        			idea.title = originalTitle;
                        		}, originSession);
                        		return true;
                        	};
                        	contentAggregate.updateTitle = function (ideaId, title) {
                        		return contentAggregate.execCommand(&#x27;updateTitle&#x27;, arguments);
                        	};
                        	commandProcessors.updateTitle = function (originSession, ideaId, title) {
                        		var idea = findIdeaById(ideaId), originalTitle;
                        		if (!idea) {
                        			return false;
                        		}
                        		originalTitle = idea.title;
                        		if (originalTitle == title) {
                        			return false;
                        		}
                        		idea.title = title;
                        		logChange(&#x27;updateTitle&#x27;, [ideaId, title], function () {
                        			idea.title = originalTitle;
                        		}, originSession);
                        		return true;
                        	};
                        	contentAggregate.addSubIdea = function (parentId, ideaTitle, optionalNewId) {
                        		return contentAggregate.execCommand(&#x27;addSubIdea&#x27;, arguments);
                        	};
                        	commandProcessors.addSubIdea = function (originSession, parentId, ideaTitle, optionalNewId) {
                        		var idea, parent = findIdeaById(parentId), newRank;
                        		if (!parent) {
                        			return false;
                        		}
                        		if (optionalNewId &amp;&amp; findIdeaById(optionalNewId)) {
                        			return false;
                        		}
                        		idea = init({
                        			title: ideaTitle,
                        			id: optionalNewId
                        		});
                        		newRank = appendSubIdea(parent, idea);
                        		logChange(&#x27;addSubIdea&#x27;, [parentId, ideaTitle, idea.id], function () {
                        			delete parent.ideas[newRank];
                        		}, originSession);
                        		return idea.id;
                        	};
                        	contentAggregate.removeMultiple = function (subIdeaIdArray) {
                        		contentAggregate.startBatch();
                        		var results = _.map(subIdeaIdArray, contentAggregate.removeSubIdea);
                        		contentAggregate.endBatch();
                        		return results;
                        	};
                        	contentAggregate.removeSubIdea = function (subIdeaId) {
                        		return contentAggregate.execCommand(&#x27;removeSubIdea&#x27;, arguments);
                        	};
                        	commandProcessors.removeSubIdea = function (originSession, subIdeaId) {
                        		var parent = contentAggregate.findParent(subIdeaId), oldRank, oldIdea, oldLinks;
                        		if (parent) {
                        			oldRank = parent.findChildRankById(subIdeaId);
                        			oldIdea = parent.ideas[oldRank];
                        			delete parent.ideas[oldRank];
                        			oldLinks = contentAggregate.links;
                        			contentAggregate.links = _.reject(contentAggregate.links, function (link) { return link.ideaIdFrom == subIdeaId || link.ideaIdTo == subIdeaId; });
                        			logChange(&#x27;removeSubIdea&#x27;, [subIdeaId], function () {
                        				parent.ideas[oldRank] = oldIdea;
                        				contentAggregate.links = oldLinks;
                        			}, originSession);
                        			return true;
                        		}
                        		return false;
                        	};
                        	contentAggregate.insertIntermediateMultiple = function (idArray) {
                        		contentAggregate.startBatch();
                        		var newId = contentAggregate.insertIntermediate(idArray[0]);
                        		_.each(idArray.slice(1), function (id) {
                        			contentAggregate.changeParent(id, newId);
                        		});
                        		contentAggregate.endBatch();
                        		return newId;
                        	};
                        	contentAggregate.insertIntermediate = function (inFrontOfIdeaId, title, optionalNewId) {
                        		return contentAggregate.execCommand(&#x27;insertIntermediate&#x27;, arguments);
                        	};
                        	commandProcessors.insertIntermediate = function (originSession, inFrontOfIdeaId, title, optionalNewId) {
                        		if (contentAggregate.id == inFrontOfIdeaId) {
                        			return false;
                        		}
                        		var childRank, oldIdea, newIdea, parentIdea = contentAggregate.findParent(inFrontOfIdeaId);
                        		if (!parentIdea) {
                        			return false;
                        		}
                        		if (optionalNewId &amp;&amp; findIdeaById(optionalNewId)) {
                        			return false;
                        		}
                        		childRank = parentIdea.findChildRankById(inFrontOfIdeaId);
                        		if (!childRank) {
                        			return false;
                        		}
                        		oldIdea = parentIdea.ideas[childRank];
                        		newIdea = init({
                        			title: title,
                        			id: optionalNewId
                        		});
                        		parentIdea.ideas[childRank] = newIdea;
                        		newIdea.ideas = {
                        			1: oldIdea
                        		};
                        		logChange(&#x27;insertIntermediate&#x27;, [inFrontOfIdeaId, title, newIdea.id], function () {
                        			parentIdea.ideas[childRank] = oldIdea;
                        		}, originSession);
                        		return newIdea.id;
                        	};
                        	contentAggregate.changeParent = function (ideaId, newParentId) {
                        		return contentAggregate.execCommand(&#x27;changeParent&#x27;, arguments);
                        	};
                        	commandProcessors.changeParent = function (originSession, ideaId, newParentId) {
                        		var oldParent, oldRank, newRank, idea, parent = findIdeaById(newParentId), oldPosition;
                        		if (ideaId == newParentId) {
                        			return false;
                        		}
                        		if (!parent) {
                        			return false;
                        		}
                        		idea = contentAggregate.findSubIdeaById(ideaId);
                        		if (!idea) {
                        			return false;
                        		}
                        		if (idea.findSubIdeaById(newParentId)) {
                        			return false;
                        		}
                        		if (parent.containsDirectChild(ideaId)) {
                        			return false;
                        		}
                        		oldParent = contentAggregate.findParent(ideaId);
                        		if (!oldParent) {
                        			return false;
                        		}
                        		oldRank = oldParent.findChildRankById(ideaId);
                        		newRank = appendSubIdea(parent, idea);
                        		oldPosition = idea.getAttr(&#x27;position&#x27;);
                        		updateAttr(idea, &#x27;position&#x27;);
                        		delete oldParent.ideas[oldRank];
                        		logChange(&#x27;changeParent&#x27;, [ideaId, newParentId], function () {
                        			updateAttr(idea, &#x27;position&#x27;, oldPosition);
                        			oldParent.ideas[oldRank] = idea;
                        			delete parent.ideas[newRank];
                        		}, originSession);
                        		return true;
                        	};
                        	var updateAttr = function (object, attrName, attrValue) {
                        		var oldAttr;
                        		if (!object) {
                        			return false;
                        		}
                        		oldAttr = _.extend({}, object.attr);
                        		object.attr = _.extend({}, object.attr);
                        		if (!attrValue || attrValue === &#x27;false&#x27; || (_.isObject(attrValue) &amp;&amp; _.isEmpty(attrValue))) {
                        			if (!object.attr[attrName]) {
                        				return false;
                        			}
                        			delete object.attr[attrName];
                        		} else {
                        			if (_.isEqual(object.attr[attrName], attrValue)) {
                        				return false;
                        			}
                        			object.attr[attrName] = JSON.parse(JSON.stringify(attrValue));
                        		}
                        		if (_.size(object.attr) === 0) {
                        			delete object.attr;
                        		}
                        		return function () {
                        			object.attr = oldAttr;
                        		};
                        	};
                        	contentAggregate.mergeAttrProperty = function (ideaId, attrName, attrPropertyName, attrPropertyValue) {
                        		var val = contentAggregate.getAttrById(ideaId, attrName) || {};
                        		if (attrPropertyValue) {
                        			val[attrPropertyName] = attrPropertyValue;
                        		} else {
                        			delete val[attrPropertyName];
                        		}
                        		if (_.isEmpty(val)) { val = false; }
                        		return contentAggregate.updateAttr(ideaId, attrName, val);
                        	};
                        	contentAggregate.updateAttr = function (ideaId, attrName, attrValue) {
                        		return contentAggregate.execCommand(&#x27;updateAttr&#x27;, arguments);
                        	};
                        	commandProcessors.updateAttr = function (originSession, ideaId, attrName, attrValue) {
                        		var idea = findIdeaById(ideaId), undoAction;
                        		undoAction = updateAttr(idea, attrName, attrValue);
                        		if (undoAction) {
                        			logChange(&#x27;updateAttr&#x27;, [ideaId, attrName, attrValue], undoAction, originSession);
                        		}
                        		return !!undoAction;
                        	};
                        	contentAggregate.moveRelative = function (ideaId, relativeMovement) {
                        		var parentIdea = contentAggregate.findParent(ideaId),
                        			currentRank = parentIdea &amp;&amp; parentIdea.findChildRankById(ideaId),
                        			siblingRanks = currentRank &amp;&amp; _.sortBy(sameSideSiblingRanks(parentIdea, currentRank), Math.abs),
                        			currentIndex = siblingRanks &amp;&amp; siblingRanks.indexOf(currentRank),
                        			/* we call positionBefore, so movement down is actually 2 spaces, not 1 */
                        			newIndex = currentIndex + (relativeMovement &gt; 0 ? relativeMovement + 1 : relativeMovement),
                        			beforeSibling = (newIndex &gt;= 0) &amp;&amp; parentIdea &amp;&amp; siblingRanks &amp;&amp; parentIdea.ideas[siblingRanks[newIndex]];
                        		if (newIndex &lt; 0 || !parentIdea) {
                        			return false;
                        		}
                        		return contentAggregate.positionBefore(ideaId, beforeSibling &amp;&amp; beforeSibling.id, parentIdea);
                        	};
                        	contentAggregate.positionBefore = function (ideaId, positionBeforeIdeaId, parentIdea) {
                        		return contentAggregate.execCommand(&#x27;positionBefore&#x27;, arguments);
                        	};
                        	commandProcessors.positionBefore = function (originSession, ideaId, positionBeforeIdeaId, parentIdea) {
                        		parentIdea = parentIdea || contentAggregate;
                        		var newRank, afterRank, siblingRanks, candidateSiblings, beforeRank, maxRank, currentRank;
                        		currentRank = parentIdea.findChildRankById(ideaId);
                        		if (!currentRank) {
                        			return _.reduce(
                        				parentIdea.ideas,
                        				function (result, idea) {
                        					return result || commandProcessors.positionBefore(originSession, ideaId, positionBeforeIdeaId, idea);
                        				},
                        				false
                        			);
                        		}
                        		if (ideaId == positionBeforeIdeaId) {
                        			return false;
                        		}
                        		newRank = 0;
                        		if (positionBeforeIdeaId) {
                        			afterRank = parentIdea.findChildRankById(positionBeforeIdeaId);
                        			if (!afterRank) {
                        				return false;
                        			}
                        			siblingRanks = sameSideSiblingRanks(parentIdea, currentRank);
                        			candidateSiblings = _.reject(_.sortBy(siblingRanks, Math.abs), function (k) {
                        				return Math.abs(k) &gt;= Math.abs(afterRank);
                        			});
                        			beforeRank = candidateSiblings.length &gt; 0 ? _.max(candidateSiblings, Math.abs) : 0;
                        			if (beforeRank == currentRank) {
                        				return false;
                        			}
                        			newRank = beforeRank + (afterRank - beforeRank) / 2;
                        		} else {
                        			maxRank = maxKey(parentIdea.ideas, currentRank &lt; 0 ? -1 : 1);
                        			if (maxRank == currentRank) {
                        				return false;
                        			}
                        			newRank = maxRank + 10 * (currentRank &lt; 0 ? -1 : 1);
                        		}
                        		if (newRank == currentRank) {
                        			return false;
                        		}
                        		reorderChild(parentIdea, newRank, currentRank);
                        		logChange(&#x27;positionBefore&#x27;, [ideaId, positionBeforeIdeaId], function () {
                        			reorderChild(parentIdea, currentRank, newRank);
                        		}, originSession);
                        		return true;
                        	};
                        	observable(contentAggregate);
                        	(function () {
                        		var isLinkValid = function (ideaIdFrom, ideaIdTo) {
                        			var isParentChild, ideaFrom, ideaTo;
                        			if (ideaIdFrom === ideaIdTo) {
                        				return false;
                        			}
                        			ideaFrom = findIdeaById(ideaIdFrom);
                        			if (!ideaFrom) {
                        				return false;
                        			}
                        			ideaTo = findIdeaById(ideaIdTo);
                        			if (!ideaTo) {
                        				return false;
                        			}
                        			isParentChild = _.find(
                        				ideaFrom.ideas,
                        				function (node) {
                        					return node.id === ideaIdTo;
                        				}
                        			) || _.find(
                        				ideaTo.ideas,
                        				function (node) {
                        					return node.id === ideaIdFrom;
                        				}
                        			);
                        			if (isParentChild) {
                        				return false;
                        			}
                        			return true;
                        		};
                        		contentAggregate.addLink = function (ideaIdFrom, ideaIdTo) {
                        			return contentAggregate.execCommand(&#x27;addLink&#x27;, arguments);
                        		};
                        		commandProcessors.addLink = function (originSession, ideaIdFrom, ideaIdTo) {
                        			var alreadyExists, link;
                        			if (!isLinkValid(ideaIdFrom, ideaIdTo)) {
                        				return false;
                        			}
                        			alreadyExists = _.find(
                        				contentAggregate.links,
                        				function (link) {
                        					return (link.ideaIdFrom === ideaIdFrom &amp;&amp; link.ideaIdTo === ideaIdTo) || (link.ideaIdFrom === ideaIdTo &amp;&amp; link.ideaIdTo === ideaIdFrom);
                        				}
                        			);
                        			if (alreadyExists) {
                        				return false;
                        			}
                        			contentAggregate.links = contentAggregate.links || [];
                        			link = {
                        				ideaIdFrom: ideaIdFrom,
                        				ideaIdTo: ideaIdTo,
                        				attr: {
                        					style: {
                        						color: &#x27;#FF0000&#x27;,
                        						lineStyle: &#x27;dashed&#x27;
                        					}
                        				}
                        			};
                        			contentAggregate.links.push(link);
                        			logChange(&#x27;addLink&#x27;, [ideaIdFrom, ideaIdTo], function () {
                        				contentAggregate.links.pop();
                        			}, originSession);
                        			return true;
                        		};
                        		contentAggregate.removeLink = function (ideaIdOne, ideaIdTwo) {
                        			return contentAggregate.execCommand(&#x27;removeLink&#x27;, arguments);
                        		};
                        		commandProcessors.removeLink = function (originSession, ideaIdOne, ideaIdTwo) {
                        			var i = 0, link;
                        
                        			while (contentAggregate.links &amp;&amp; i &lt; contentAggregate.links.length) {
                        				link = contentAggregate.links[i];
                        				if (String(link.ideaIdFrom) === String(ideaIdOne) &amp;&amp; String(link.ideaIdTo) === String(ideaIdTwo)) {
                        					contentAggregate.links.splice(i, 1);
                        					logChange(&#x27;removeLink&#x27;, [ideaIdOne, ideaIdTwo], function () {
                        						contentAggregate.links.push(_.clone(link));
                        					}, originSession);
                        					return true;
                        				}
                        				i += 1;
                        			}
                        			return false;
                        		};
                        		contentAggregate.getLinkAttr = function (ideaIdFrom, ideaIdTo, name) {
                        			var link = _.find(
                        				contentAggregate.links,
                        				function (link) {
                        					return link.ideaIdFrom == ideaIdFrom &amp;&amp; link.ideaIdTo == ideaIdTo;
                        				}
                        			);
                        			if (link &amp;&amp; link.attr &amp;&amp; link.attr[name]) {
                        				return link.attr[name];
                        			}
                        			return false;
                        		};
                        		contentAggregate.updateLinkAttr = function (ideaIdFrom, ideaIdTo, attrName, attrValue) {
                        			return contentAggregate.execCommand(&#x27;updateLinkAttr&#x27;, arguments);
                        		};
                        		commandProcessors.updateLinkAttr = function (originSession, ideaIdFrom, ideaIdTo, attrName, attrValue) {
                        			var link = _.find(
                        				contentAggregate.links,
                        				function (link) {
                        					return link.ideaIdFrom == ideaIdFrom &amp;&amp; link.ideaIdTo == ideaIdTo;
                        				}
                        			), undoAction;
                        			undoAction = updateAttr(link, attrName, attrValue);
                        			if (undoAction) {
                        				logChange(&#x27;updateLinkAttr&#x27;, [ideaIdFrom, ideaIdTo, attrName, attrValue], undoAction, originSession);
                        			}
                        			return !!undoAction;
                        		};
                        	}());
                        	/* undo/redo */
                        	contentAggregate.undo = function () {
                        		return contentAggregate.execCommand(&#x27;undo&#x27;, arguments);
                        	};
                        	commandProcessors.undo = function (originSession) {
                        		contentAggregate.endBatch();
                        		var topEvent;
                        		topEvent = eventStacks[originSession] &amp;&amp; eventStacks[originSession].pop();
                        		if (topEvent &amp;&amp; topEvent.undoFunction) {
                        			topEvent.undoFunction();
                        			if (!redoStacks[originSession]) {
                        				redoStacks[originSession] = [];
                        			}
                        			redoStacks[originSession].push(topEvent);
                        			contentAggregate.dispatchEvent(&#x27;changed&#x27;, &#x27;undo&#x27;, [], originSession);
                        			return true;
                        		}
                        		return false;
                        	};
                        	contentAggregate.redo = function () {
                        		return contentAggregate.execCommand(&#x27;redo&#x27;, arguments);
                        	};
                        	commandProcessors.redo = function (originSession) {
                        		contentAggregate.endBatch();
                        		var topEvent;
                        		topEvent = redoStacks[originSession] &amp;&amp; redoStacks[originSession].pop();
                        		if (topEvent) {
                        			isRedoInProgress = true;
                        			contentAggregate.execCommand(topEvent.eventMethod, topEvent.eventArgs, originSession);
                        			isRedoInProgress = false;
                        			return true;
                        		}
                        		return false;
                        	};
                        	contentAggregate.storeResource = function (/*resourceBody, optionalKey*/) {
                        		return contentAggregate.execCommand(&#x27;storeResource&#x27;, arguments);
                        	};
                        	commandProcessors.storeResource = function (originSession, resourceBody, optionalKey) {
                        		if (!optionalKey &amp;&amp; contentAggregate.resources) {
                        			var existingId = _.find(_.keys(contentAggregate.resources), function (key) {
                        				return contentAggregate.resources[key] === resourceBody;
                        			});
                        			if (existingId) {
                        				return existingId;
                        			}
                        		}
                        		var maxIdForSession = function () {
                        				if (_.isEmpty(contentAggregate.resources)) {
                        					return 0;
                        				}
                        				var toInt = function (string) {
                        						return parseInt(string, 10);
                        					},
                        					keys = _.keys(contentAggregate.resources),
                        					filteredKeys = sessionKey ? _.filter(keys, RegExp.prototype.test.bind(new RegExp(&#x27;\\/&#x27; + sessionKey + &#x27;$&#x27;))) : keys,
                        					intKeys = _.map(filteredKeys, toInt);
                        				return _.isEmpty(intKeys) ? 0 : _.max(intKeys);
                        			},
                        			nextResourceId = function () {
                        				var intId = maxIdForSession() + 1;
                        				return intId + uniqueResourcePostfix;
                        			},
                        			id = optionalKey || nextResourceId();
                        		contentAggregate.resources = contentAggregate.resources || {};
                        		contentAggregate.resources[id] = resourceBody;
                        		contentAggregate.dispatchEvent(&#x27;resourceStored&#x27;, resourceBody, id, originSession);
                        		return id;
                        	};
                        	contentAggregate.getResource = function (id) {
                        		return contentAggregate.resources &amp;&amp; contentAggregate.resources[id];
                        	};
                        	if (contentAggregate.formatVersion != 2) {
                        		upgrade(contentAggregate);
                        		contentAggregate.formatVersion = 2;
                        	}
                        	init(contentAggregate);
                        	return contentAggregate;
                        };
                        /*jslint nomen: true*/
                        /*global _, Color, MAPJS*/
                        MAPJS.defaultStyles = { };
                        MAPJS.layoutLinks = function (idea, visibleNodes) {
                        	&#x27;use strict&#x27;;
                        	var result = {};
                        	_.each(idea.links, function (link) {
                        		if (visibleNodes[link.ideaIdFrom] &amp;&amp; visibleNodes[link.ideaIdTo]) {
                        			result[link.ideaIdFrom + &#x27;_&#x27; + link.ideaIdTo] = {
                        				ideaIdFrom: link.ideaIdFrom,
                        				ideaIdTo: link.ideaIdTo,
                        				attr: _.clone(link.attr)
                        			};
                        			//todo - clone
                        		}
                        	});
                        	return result;
                        };
                        MAPJS.calculateFrame = function (nodes, margin) {
                        	&#x27;use strict&#x27;;
                        	margin = margin || 0;
                        	var result = {
                        		top: _.min(nodes, function (node) {return node.y; }).y - margin,
                        		left: _.min(nodes, function (node) {return node.x; }).x - margin
                        	};
                        	result.width = margin + _.max(_.map(nodes, function (node) { return node.x + node.width; })) - result.left;
                        	result.height = margin + _.max(_.map(nodes, function (node) { return node.y + node.height; })) - result.top;
                        	return result;
                        };
                        MAPJS.contrastForeground = function (background) {
                        	&#x27;use strict&#x27;;
                        	/*jslint newcap:true*/
                        	var luminosity = Color(background).luminosity();
                        	if (luminosity &lt; 0.5) {
                        		return &#x27;#EEEEEE&#x27;;
                        	}
                        	if (luminosity &lt; 0.9) {
                        		return &#x27;#4F4F4F&#x27;;
                        	}
                        	return &#x27;#000000&#x27;;
                        };
                        MAPJS.Outline = function (topBorder, bottomBorder) {
                        	&#x27;use strict&#x27;;
                        	var shiftBorder = function (border, deltaH) {
                        		return _.map(border, function (segment) {
                        			return {
                        				l: segment.l,
                        				h: segment.h + deltaH
                        			};
                        		});
                        	};
                        	this.initialHeight = function () {
                        		return this.bottom[0].h - this.top[0].h;
                        	};
                        	this.borders = function () {
                        		return _.pick(this, &#x27;top&#x27;, &#x27;bottom&#x27;);
                        	};
                        	this.spacingAbove = function (outline) {
                        		var i = 0, j = 0, result = 0, li = 0, lj = 0;
                        		while (i &lt; this.bottom.length &amp;&amp; j &lt; outline.top.length) {
                        			result = Math.max(result, this.bottom[i].h - outline.top[j].h);
                        			if (li + this.bottom[i].l &lt; lj + outline.top[j].l) {
                        				li += this.bottom[i].l;
                        				i += 1;
                        			} else if (li + this.bottom[i].l === lj + outline.top[j].l) {
                        				li += this.bottom[i].l;
                        				i += 1;
                        				lj += outline.top[j].l;
                        				j += 1;
                        			} else {
                        				lj += outline.top[j].l;
                        				j += 1;
                        			}
                        		}
                        		return result;
                        	};
                        	this.indent = function (horizontalIndent, margin) {
                        		if (!horizontalIndent) {
                        			return this;
                        		}
                        		var top = this.top.slice(),
                        			bottom = this.bottom.slice(),
                        			vertCenter = (bottom[0].h + top[0].h) / 2;
                        		top.unshift({h: vertCenter - margin / 2, l: horizontalIndent});
                        		bottom.unshift({h: vertCenter + margin / 2, l: horizontalIndent});
                        		return new MAPJS.Outline(top, bottom);
                        	};
                        	this.stackBelow = function (outline, margin) {
                        		var spacing = outline.spacingAbove(this),
                        			top = MAPJS.Outline.extendBorder(outline.top, shiftBorder(this.top, spacing + margin)),
                        			bottom = MAPJS.Outline.extendBorder(shiftBorder(this.bottom, spacing + margin), outline.bottom);
                        		return new MAPJS.Outline(
                        			top,
                        			bottom
                        		);
                        	};
                        	this.expand = function (initialTopHeight, initialBottomHeight) {
                        		var topAlignment = initialTopHeight - this.top[0].h,
                        			bottomAlignment = initialBottomHeight - this.bottom[0].h,
                        			top = shiftBorder(this.top, topAlignment),
                        			bottom = shiftBorder(this.bottom, bottomAlignment);
                        		return new MAPJS.Outline(
                        			top,
                        			bottom
                        		);
                        	};
                        	this.insertAtStart = function (dimensions, margin) {
                        		var alignment = 0, //-1 * this.top[0].h - suboutlineHeight * 0.5,
                        			topBorder = shiftBorder(this.top, alignment),
                        			bottomBorder = shiftBorder(this.bottom, alignment),
                        			easeIn = function (border) {
                        				border[0].l *= 0.5;
                        				border[1].l += border[0].l;
                        			};
                        		topBorder[0].l += margin;
                        		bottomBorder[0].l += margin;
                        		topBorder.unshift({h: -0.5 * dimensions.height, l: dimensions.width});
                        		bottomBorder.unshift({h: 0.5 * dimensions.height, l: dimensions.width});
                        		if (topBorder[0].h &gt; topBorder[1].h) {
                        			easeIn(topBorder);
                        		}
                        		if (bottomBorder[0].h &lt; bottomBorder[1].h) {
                        			easeIn(bottomBorder);
                        		}
                        		return new MAPJS.Outline(topBorder, bottomBorder);
                        	};
                        	this.top = topBorder.slice();
                        	this.bottom = bottomBorder.slice();
                        };
                        MAPJS.Outline.borderLength = function (border) {
                        	&#x27;use strict&#x27;;
                        	return _.reduce(border, function (seed, el) {
                        		return seed + el.l;
                        	}, 0);
                        };
                        MAPJS.Outline.borderSegmentIndexAt = function (border, length) {
                        	&#x27;use strict&#x27;;
                        	var l = 0, i = -1;
                        	while (l &lt;= length) {
                        		i += 1;
                        		if (i &gt;= border.length) {
                        			return -1;
                        		}
                        		l += border[i].l;
                        	}
                        	return i;
                        };
                        MAPJS.Outline.extendBorder = function (originalBorder, extension) {
                        	&#x27;use strict&#x27;;
                        	var result = originalBorder.slice(),
                        		origLength = MAPJS.Outline.borderLength(originalBorder),
                        		i = MAPJS.Outline.borderSegmentIndexAt(extension, origLength),
                        		lengthToCut;
                        	if (i &gt;= 0) {
                        		lengthToCut = MAPJS.Outline.borderLength(extension.slice(0, i + 1));
                        		result.push({h: extension[i].h, l: lengthToCut - origLength});
                        		result = result.concat(extension.slice(i + 1));
                        	}
                        	return result;
                        };
                        MAPJS.Tree = function (options) {
                        	&#x27;use strict&#x27;;
                        	_.extend(this, options);
                        	this.toLayout = function (x, y, parentId) {
                        		x = x || 0;
                        		y = y || 0;
                        		var result = {
                        			nodes: {},
                        			connectors: {}
                        		}, self;
                        		self = _.pick(this, &#x27;id&#x27;, &#x27;title&#x27;, &#x27;attr&#x27;, &#x27;width&#x27;, &#x27;height&#x27;, &#x27;level&#x27;);
                        		if (self.level === 1) {
                        			self.x = -0.5 * this.width;
                        			self.y = -0.5 * this.height;
                        		} else {
                        			self.x = x + this.deltaX || 0;
                        			self.y = y + this.deltaY || 0;
                        		}
                        		result.nodes[this.id] = self;
                        		if (parentId !== undefined) {
                        			result.connectors[self.id] = {
                        				from: parentId,
                        				to: self.id
                        			};
                        		}
                        		if (this.subtrees) {
                        			this.subtrees.forEach(function (t) {
                        				var subLayout = t.toLayout(self.x, self.y, self.id);
                        				_.extend(result.nodes, subLayout.nodes);
                        				_.extend(result.connectors, subLayout.connectors);
                        			});
                        		}
                        		return result;
                        	};
                        };
                        MAPJS.Outline.fromDimensions = function (dimensions) {
                        	&#x27;use strict&#x27;;
                        	return new MAPJS.Outline([{
                        		h: -0.5 * dimensions.height,
                        		l: dimensions.width
                        	}], [{
                        		h: 0.5 * dimensions.height,
                        		l: dimensions.width
                        	}]);
                        };
                        MAPJS.calculateTree = function (content, dimensionProvider, margin, rankAndParentPredicate, level) {
                        	&#x27;use strict&#x27;;
                        	var options = {
                        		id: content.id,
                        		title: content.title,
                        		attr: content.attr,
                        		deltaY: 0,
                        		deltaX: 0,
                        		level: level || 1
                        	},
                        		setVerticalSpacing = function (treeArray,  dy) {
                        			var i,
                        				tree,
                        				oldSpacing,
                        				newSpacing,
                        				oldPositions = _.map(treeArray, function (t) { return _.pick(t, &#x27;deltaX&#x27;, &#x27;deltaY&#x27;); }),
                        				referenceTree,
                        				alignment;
                        			for (i = 0; i &lt; treeArray.length; i += 1) {
                        				tree = treeArray[i];
                        				if (tree.attr &amp;&amp; tree.attr.position) {
                        					tree.deltaY = tree.attr.position[1];
                        					if (referenceTree === undefined || tree.attr.position[2] &gt; treeArray[referenceTree].attr.position[2]) {
                        						referenceTree = i;
                        					}
                        				} else {
                        					tree.deltaY += dy;
                        				}
                        				if (i &gt; 0) {
                        					oldSpacing = oldPositions[i].deltaY - oldPositions[i - 1].deltaY;
                        					newSpacing = treeArray[i].deltaY - treeArray[i - 1].deltaY;
                        					if (newSpacing &lt; oldSpacing) {
                        						tree.deltaY += oldSpacing - newSpacing;
                        					}
                        				}
                        			}
                        			alignment =  referenceTree &amp;&amp; (treeArray[referenceTree].attr.position[1] - treeArray[referenceTree].deltaY);
                        			if (alignment) {
                        				for (i = 0; i &lt; treeArray.length; i += 1) {
                        					treeArray[i].deltaY += alignment;
                        				}
                        			}
                        		},
                        		shouldIncludeSubIdeas = function () {
                        			return !(_.isEmpty(content.ideas) || (content.attr &amp;&amp; content.attr.collapsed));
                        		},
                        		includedSubIdeaKeys = function () {
                        			var allRanks = _.map(_.keys(content.ideas), parseFloat),
                        				includedRanks = rankAndParentPredicate ? _.filter(allRanks, function (rank) { return rankAndParentPredicate(rank, content.id); }) : allRanks;
                        			return _.sortBy(includedRanks, Math.abs);
                        		},
                        		includedSubIdeas = function () {
                        			var result = [];
                        			_.each(includedSubIdeaKeys(), function (key) {
                        				result.push(content.ideas[key]);
                        			});
                        			return result;
                        		},
                        		nodeDimensions = dimensionProvider(content, options.level),
                        		appendSubtrees = function (subtrees) {
                        			var suboutline, deltaHeight, subtreePosition, horizontal, treeOutline;
                        			_.each(subtrees, function (subtree) {
                        				subtree.deltaX = nodeDimensions.width + margin;
                        				subtreePosition = subtree.attr &amp;&amp; subtree.attr.position &amp;&amp; subtree.attr.position[0];
                        				if (subtreePosition &amp;&amp; subtreePosition &gt; subtree.deltaX) {
                        					horizontal = subtreePosition - subtree.deltaX;
                        					subtree.deltaX = subtreePosition;
                        				} else {
                        					horizontal = 0;
                        				}
                        				if (!suboutline) {
                        					suboutline = subtree.outline.indent(horizontal, margin);
                        				} else {
                        					treeOutline = subtree.outline.indent(horizontal, margin);
                        					deltaHeight = treeOutline.initialHeight();
                        					suboutline = treeOutline.stackBelow(suboutline, margin);
                        					subtree.deltaY = suboutline.initialHeight() - deltaHeight / 2 - subtree.height / 2;
                        				}
                        			});
                        			if (subtrees &amp;&amp; subtrees.length) {
                        				setVerticalSpacing(subtrees, 0.5 * (nodeDimensions.height  - suboutline.initialHeight()));
                        				suboutline = suboutline.expand(
                        					subtrees[0].deltaY - nodeDimensions.height * 0.5,
                        					subtrees[subtrees.length - 1].deltaY + subtrees[subtrees.length - 1].height - nodeDimensions.height * 0.5
                        				);
                        			}
                        			options.outline = suboutline.insertAtStart(nodeDimensions, margin);
                        		};
                        	_.extend(options, nodeDimensions);
                        	options.outline = new MAPJS.Outline.fromDimensions(nodeDimensions);
                        	if (shouldIncludeSubIdeas()) {
                        		options.subtrees = _.map(includedSubIdeas(), function (i) {
                        			return MAPJS.calculateTree(i, dimensionProvider, margin, rankAndParentPredicate, options.level + 1);
                        		});
                        		if (!_.isEmpty(options.subtrees)) {
                        			appendSubtrees(options.subtrees);
                        		}
                        	}
                        	return new MAPJS.Tree(options);
                        };
                        
                        MAPJS.calculateLayout = function (idea, dimensionProvider, margin) {
                        	&#x27;use strict&#x27;;
                        	var positiveTree, negativeTree, layout, negativeLayout,
                        		setDefaultStyles = function (nodes) {
                        			_.each(nodes, function (node) {
                        				node.attr = node.attr || {};
                        				node.attr.style = _.extend({}, MAPJS.defaultStyles[(node.level === 1) ? &#x27;root&#x27; : &#x27;nonRoot&#x27;], node.attr.style);
                        			});
                        		},
                        		positive = function (rank, parentId) { return parentId !== idea.id || rank &gt; 0; },
                        		negative = function (rank, parentId) { return parentId !== idea.id || rank &lt; 0; };
                        	margin = margin || 20;
                        	positiveTree = MAPJS.calculateTree(idea, dimensionProvider, margin, positive);
                        	negativeTree = MAPJS.calculateTree(idea, dimensionProvider, margin, negative);
                        	layout = positiveTree.toLayout();
                        	negativeLayout = negativeTree.toLayout();
                        	_.each(negativeLayout.nodes, function (n) {
                        		n.x = -1 * n.x - n.width;
                        	});
                        	_.extend(negativeLayout.nodes, layout.nodes);
                        	_.extend(negativeLayout.connectors, layout.connectors);
                        	setDefaultStyles(negativeLayout.nodes);
                        	negativeLayout.links = MAPJS.layoutLinks(idea, negativeLayout.nodes);
                        	negativeLayout.rootNodeId = idea.id;
                        	return negativeLayout;
                        };
                        
                        /*global MAPJS*/
                        MAPJS.MemoryClipboard = function () {
                        	&#x27;use strict&#x27;;
                        	var self = this,
                        		clone = function (something) {
                        			if (!something) {
                        				return undefined;
                        			}
                        			return JSON.parse(JSON.stringify(something));
                        		},
                        		contents;
                        	self.get = function () {
                        		return clone(contents);
                        	};
                        	self.put = function (c) {
                        		contents = clone(c);
                        	};
                        };
                        /*global $, Hammer*/
                        /*jslint newcap:true*/
                        (function () {
                        	&#x27;use strict&#x27;;
                        	$.fn.simpleDraggableContainer = function () {
                        		var currentDragObject,
                        			originalDragObjectPosition,
                        			container = this,
                        			drag = function (event) {
                        
                        				if (currentDragObject &amp;&amp; event.gesture) {
                        					var newpos = {
                        							top: Math.round(parseInt(originalDragObjectPosition.top, 10) + event.gesture.deltaY),
                        							left: Math.round(parseInt(originalDragObjectPosition.left, 10) + event.gesture.deltaX)
                        						};
                        					currentDragObject.css(newpos).trigger($.Event(&#x27;mm:drag&#x27;, {currentPosition: newpos, gesture: event.gesture}));
                        					if (event.gesture) {
                        						event.gesture.preventDefault();
                        					}
                        					return false;
                        				}
                        			},
                        			rollback = function (e) {
                        				var target = currentDragObject; // allow it to be cleared while animating
                        				if (target.attr(&#x27;mapjs-drag-role&#x27;) !== &#x27;shadow&#x27;) {
                        					target.animate(originalDragObjectPosition, {
                        						complete: function () {
                        							target.trigger($.Event(&#x27;mm:cancel-dragging&#x27;, {gesture: e.gesture}));
                        						},
                        						progress: function () {
                        							target.trigger(&#x27;mm:drag&#x27;);
                        						}
                        					});
                        				} else {
                        					target.trigger($.Event(&#x27;mm:cancel-dragging&#x27;, {gesture: e.gesture}));
                        				}
                        			};
                        		Hammer(this, {&#x27;drag_min_distance&#x27;: 2});
                        		return this.on(&#x27;mm:start-dragging&#x27;, function (event) {
                        			if (!currentDragObject) {
                        				currentDragObject = $(event.relatedTarget);
                        				originalDragObjectPosition = {
                        					top: currentDragObject.css(&#x27;top&#x27;),
                        					left: currentDragObject.css(&#x27;left&#x27;)
                        				};
                        				$(this).on(&#x27;drag&#x27;, drag);
                        			}
                        		}).on(&#x27;mm:start-dragging-shadow&#x27;, function (event) {
                        			var target = $(event.relatedTarget),
                        				clone = function () {
                        					var result = target.clone().addClass(&#x27;drag-shadow&#x27;).appendTo(container).offset(target.offset()).data(target.data()).attr(&#x27;mapjs-drag-role&#x27;, &#x27;shadow&#x27;),
                        						scale = target.parent().data(&#x27;scale&#x27;) || 1;
                        					if (scale !== 0) {
                        						result.css({
                        							&#x27;transform&#x27;: &#x27;scale(&#x27; + scale + &#x27;)&#x27;,
                        							&#x27;transform-origin&#x27;: &#x27;top left&#x27;
                        						});
                        					}
                        					return result;
                        				};
                        			if (!currentDragObject) {
                        				currentDragObject = clone();
                        				originalDragObjectPosition = {
                        					top: currentDragObject.css(&#x27;top&#x27;),
                        					left: currentDragObject.css(&#x27;left&#x27;)
                        				};
                        				currentDragObject.on(&#x27;mm:stop-dragging mm:cancel-dragging&#x27;, function (e) {
                        					this.remove();
                        					e.stopPropagation();
                        					e.stopImmediatePropagation();
                        					var evt = $.Event(e.type, {
                        						gesture: e.gesture,
                        						finalPosition: e.finalPosition
                        					});
                        					target.trigger(evt);
                        				}).on(&#x27;mm:drag&#x27;, function (e) { target.trigger(e); });
                        				$(this).on(&#x27;drag&#x27;, drag);
                        			}
                        		}).on(&#x27;dragend&#x27;, function (e) {
                        			$(this).off(&#x27;drag&#x27;, drag);
                        			if (currentDragObject) {
                        				var evt = $.Event(&#x27;mm:stop-dragging&#x27;, {
                        					gesture: e.gesture,
                        					finalPosition: currentDragObject.offset()
                        				});
                        				currentDragObject.trigger(evt);
                        				if (evt.result === false) {
                        					rollback(e);
                        				}
                        				currentDragObject = undefined;
                        			}
                        		}).on(&#x27;mouseleave&#x27;, function (e) {
                        			if (currentDragObject) {
                        				$(this).off(&#x27;drag&#x27;, drag);
                        				rollback(e);
                        				currentDragObject = undefined;
                        			}
                        		}).attr(&#x27;data-drag-role&#x27;, &#x27;container&#x27;);
                        	};
                        
                        	var onDrag = function (e) {
                        			$(this).trigger(
                        				$.Event(&#x27;mm:start-dragging&#x27;, {
                        					relatedTarget: this,
                        					gesture: e.gesture
                        				})
                        			);
                        			e.stopPropagation();
                        			e.preventDefault();
                        			if (e.gesture) {
                        				e.gesture.stopPropagation();
                        				e.gesture.preventDefault();
                        			}
                        		}, onShadowDrag = function (e) {
                        			$(this).trigger(
                        				$.Event(&#x27;mm:start-dragging-shadow&#x27;, {
                        					relatedTarget: this,
                        					gesture: e.gesture
                        				})
                        			);
                        			e.stopPropagation();
                        			e.preventDefault();
                        			if (e.gesture) {
                        				e.gesture.stopPropagation();
                        				e.gesture.preventDefault();
                        			}
                        		};
                        	$.fn.simpleDraggable = function (options) {
                        		if (!options || !options.disable) {
                        			return $(this).on(&#x27;dragstart&#x27;, onDrag);
                        		} else {
                        			return $(this).off(&#x27;dragstart&#x27;, onDrag);
                        		}
                        	};
                        	$.fn.shadowDraggable = function (options) {
                        		if (!options || !options.disable) {
                        			return $(this).on(&#x27;dragstart&#x27;, onShadowDrag);
                        		} else {
                        			return $(this).off(&#x27;dragstart&#x27;, onShadowDrag);
                        		}
                        	};
                        })();
                        /*jslint forin: true, nomen: true*/
                        /*global _, MAPJS, observable*/
                        MAPJS.MapModel = function (layoutCalculatorArg, selectAllTitles, clipboardProvider, defaultReorderMargin) {
                        	&#x27;use strict&#x27;;
                        	var self = this,
                        		layoutCalculator = layoutCalculatorArg,
                        		reorderMargin = defaultReorderMargin || 20,
                        		clipboard = clipboardProvider || new MAPJS.MemoryClipboard(),
                        		analytic,
                        		currentLayout = {
                        			nodes: {},
                        			connectors: {}
                        		},
                        		idea,
                        		currentLabelGenerator,
                        		isInputEnabled = true,
                        		isEditingEnabled = true,
                        		currentlySelectedIdeaId,
                        		activatedNodes = [],
                        		setActiveNodes = function (activated) {
                        			var wasActivated = _.clone(activatedNodes);
                        			if (activated.length === 0) {
                        				activatedNodes = [currentlySelectedIdeaId];
                        			} else {
                        				activatedNodes = activated;
                        			}
                        			self.dispatchEvent(&#x27;activatedNodesChanged&#x27;, _.difference(activatedNodes, wasActivated), _.difference(wasActivated, activatedNodes));
                        		},
                        		horizontalSelectionThreshold = 300,
                        		isAddLinkMode,
                        		applyLabels = function (newLayout) {
                        			if (!currentLabelGenerator) {
                        				return;
                        			}
                        			var labelMap = currentLabelGenerator(idea);
                        			_.each(newLayout.nodes, function (node, id) {
                        				if (labelMap[id] || labelMap[id] === 0) {
                        					node.label = labelMap[id];
                        				}
                        			});
                        		},
                        		updateCurrentLayout = function (newLayout) {
                        			self.dispatchEvent(&#x27;layoutChangeStarting&#x27;, _.size(newLayout.nodes) - _.size(currentLayout.nodes));
                        			applyLabels(newLayout);
                        
                        			_.each(currentLayout.connectors, function (oldConnector, connectorId) {
                        				var newConnector = newLayout.connectors[connectorId];
                        				if (!newConnector || newConnector.from !== oldConnector.from || newConnector.to !== oldConnector.to) {
                        					self.dispatchEvent(&#x27;connectorRemoved&#x27;, oldConnector);
                        				}
                        			});
                        			_.each(currentLayout.links, function (oldLink, linkId) {
                        				var newLink = newLayout.links &amp;&amp; newLayout.links[linkId];
                        				if (!newLink) {
                        					self.dispatchEvent(&#x27;linkRemoved&#x27;, oldLink);
                        				}
                        			});
                        			_.each(currentLayout.nodes, function (oldNode, nodeId) {
                        				var newNode = newLayout.nodes[nodeId],
                        					newActive;
                        				if (!newNode) {
                        					/*jslint eqeq: true*/
                        					if (nodeId == currentlySelectedIdeaId) {
                        						self.selectNode(idea.id);
                        					}
                        					newActive = _.reject(activatedNodes, function (e) { return e == nodeId; });
                        					if (newActive.length !== activatedNodes.length) {
                        						setActiveNodes(newActive);
                        					}
                        					self.dispatchEvent(&#x27;nodeRemoved&#x27;, oldNode, nodeId);
                        				}
                        			});
                        
                        			_.each(newLayout.nodes, function (newNode, nodeId) {
                        				var oldNode = currentLayout.nodes[nodeId];
                        				if (!oldNode) {
                        					self.dispatchEvent(&#x27;nodeCreated&#x27;, newNode);
                        				} else {
                        					if (newNode.x !== oldNode.x || newNode.y !== oldNode.y) {
                        						self.dispatchEvent(&#x27;nodeMoved&#x27;, newNode);
                        					}
                        					if (newNode.title !== oldNode.title) {
                        						self.dispatchEvent(&#x27;nodeTitleChanged&#x27;, newNode);
                        					}
                        					if (!_.isEqual(newNode.attr || {}, oldNode.attr || {})) {
                        						self.dispatchEvent(&#x27;nodeAttrChanged&#x27;, newNode);
                        					}
                        					if (newNode.label !== oldNode.label) {
                        						self.dispatchEvent(&#x27;nodeLabelChanged&#x27;, newNode);
                        					}
                        				}
                        			});
                        			_.each(newLayout.connectors, function (newConnector, connectorId) {
                        				var oldConnector = currentLayout.connectors[connectorId];
                        				if (!oldConnector || newConnector.from !== oldConnector.from || newConnector.to !== oldConnector.to) {
                        					self.dispatchEvent(&#x27;connectorCreated&#x27;, newConnector);
                        				}
                        			});
                        			_.each(newLayout.links, function (newLink, linkId) {
                        				var oldLink = currentLayout.links &amp;&amp; currentLayout.links[linkId];
                        				if (oldLink) {
                        					if (!_.isEqual(newLink.attr || {}, (oldLink &amp;&amp; oldLink.attr) || {})) {
                        						self.dispatchEvent(&#x27;linkAttrChanged&#x27;, newLink);
                        					}
                        				} else {
                        					self.dispatchEvent(&#x27;linkCreated&#x27;, newLink);
                        				}
                        			});
                        			currentLayout = newLayout;
                        			if (!self.isInCollapse) {
                        				self.dispatchEvent(&#x27;layoutChangeComplete&#x27;);
                        			}
                        		},
                        		revertSelectionForUndo,
                        		revertActivatedForUndo,
                        		selectNewIdea = function (newIdeaId) {
                        			revertSelectionForUndo = currentlySelectedIdeaId;
                        			revertActivatedForUndo = activatedNodes.slice(0);
                        			self.selectNode(newIdeaId);
                        		},
                        		editNewIdea = function (newIdeaId) {
                                    selectNewIdea(newIdeaId);
                        			self.editNode(false, true, true);
                        		},
                        		getCurrentlySelectedIdeaId = function () {
                        			return currentlySelectedIdeaId || idea.id;
                        		},
                        		paused = false,
                        		onIdeaChanged = function () {
                        			if (paused) {
                        				return;
                        			}
                        			revertSelectionForUndo = false;
                        			revertActivatedForUndo = false;
                        			self.rebuildRequired();
                        		},
                        		currentlySelectedIdea = function () {
                        			return (idea.findSubIdeaById(currentlySelectedIdeaId) || idea);
                        		},
                        		ensureNodeIsExpanded = function (source, nodeId) {
                        			var node = idea.findSubIdeaById(nodeId) || idea;
                        			if (node.getAttr(&#x27;collapsed&#x27;)) {
                        				idea.updateAttr(nodeId, &#x27;collapsed&#x27;, false);
                        			}
                        		};
                        	observable(this);
                        	analytic = self.dispatchEvent.bind(self, &#x27;analytic&#x27;, &#x27;mapModel&#x27;);
                        	self.pause = function () {
                        		paused = true;
                        	};
                        	self.resume = function () {
                        		paused = false;
                        		self.rebuildRequired();
                        	};
                        	self.getIdea = function () {
                        		return idea;
                        	};
                        	self.isEditingEnabled = function () {
                        		return isEditingEnabled;
                        	};
                        	self.getCurrentLayout = function () {
                        		return currentLayout;
                        	};
                        	self.analytic = analytic;
                        	self.getCurrentlySelectedIdeaId = getCurrentlySelectedIdeaId;
                        	self.rebuildRequired = function () {
                        		if (!idea) {
                        			return;
                        		}
                        		updateCurrentLayout(self.reactivate(layoutCalculator(idea)));
                        	};
                        	this.setIdea = function (anIdea) {
                        		if (idea) {
                        			idea.removeEventListener(&#x27;changed&#x27;, onIdeaChanged);
                        			paused = false;
                        			setActiveNodes([]);
                        			self.dispatchEvent(&#x27;nodeSelectionChanged&#x27;, currentlySelectedIdeaId, false);
                        			currentlySelectedIdeaId = undefined;
                        		}
                        		idea = anIdea;
                        		idea.addEventListener(&#x27;changed&#x27;, onIdeaChanged);
                        		onIdeaChanged();
                        		self.selectNode(idea.id, true);
                        		self.dispatchEvent(&#x27;mapViewResetRequested&#x27;);
                        	};
                        	this.setEditingEnabled = function (value) {
                        		isEditingEnabled = value;
                        	};
                        	this.getEditingEnabled = function () {
                        		return isEditingEnabled;
                        	};
                        	this.setInputEnabled = function (value, holdFocus) {
                        		if (isInputEnabled !== value) {
                        			isInputEnabled = value;
                        			self.dispatchEvent(&#x27;inputEnabledChanged&#x27;, value, !!holdFocus);
                        		}
                        	};
                        	this.getInputEnabled = function () {
                        		return isInputEnabled;
                        	};
                        	this.selectNode = function (id, force, appendToActive) {
                        		if (force || (isInputEnabled &amp;&amp; (id !== currentlySelectedIdeaId || !self.isActivated(id)))) {
                        			if (currentlySelectedIdeaId) {
                        				self.dispatchEvent(&#x27;nodeSelectionChanged&#x27;, currentlySelectedIdeaId, false);
                        			}
                        			currentlySelectedIdeaId = id;
                        			if (appendToActive) {
                        				self.activateNode(&#x27;internal&#x27;, id);
                        			} else {
                        				setActiveNodes([id]);
                        			}
                        
                        			self.dispatchEvent(&#x27;nodeSelectionChanged&#x27;, id, true);
                        		}
                        	};
                        	this.clickNode = function (id, event) {
                        		var button = event &amp;&amp; event.button &amp;&amp; event.button !== -1;
                        		if (event &amp;&amp; event.altKey) {
                        			self.addLink(&#x27;mouse&#x27;, id);
                        		} else if (event &amp;&amp; event.shiftKey) {
                        			/*don&#x27;t stop propagation, this is needed for drop targets*/
                        			self.toggleActivationOnNode(&#x27;mouse&#x27;, id);
                        		} else if (isAddLinkMode &amp;&amp; !button) {
                        			this.addLink(&#x27;mouse&#x27;, id);
                        			this.toggleAddLinkMode();
                        		} else {
                        			this.selectNode(id);
                        			if (button &amp;&amp; button !== -1 &amp;&amp; isInputEnabled) {
                        				self.dispatchEvent(&#x27;contextMenuRequested&#x27;, id, event.layerX, event.layerY);
                        			}
                        		}
                        	};
                        	this.findIdeaById = function (id) {
                        		/*jslint eqeq:true */
                        		if (idea.id == id) {
                        			return idea;
                        		}
                        		return idea.findSubIdeaById(id);
                        	};
                        	this.getSelectedStyle = function (prop) {
                        		return this.getStyleForId(currentlySelectedIdeaId, prop);
                        	};
                        	this.getStyleForId = function (id, prop) {
                        		var node = currentLayout.nodes &amp;&amp; currentLayout.nodes[id];
                        		return node &amp;&amp; node.attr &amp;&amp; node.attr.style &amp;&amp; node.attr.style[prop];
                        	};
                        	this.toggleCollapse = function (source) {
                        		var selectedIdea = currentlySelectedIdea(),
                        			isCollapsed;
                        		if (self.isActivated(selectedIdea.id) &amp;&amp; _.size(selectedIdea.ideas) &gt; 0) {
                        			isCollapsed = selectedIdea.getAttr(&#x27;collapsed&#x27;);
                        		} else {
                        			isCollapsed = self.everyActivatedIs(function (id) {
                        				var node = self.findIdeaById(id);
                        				if (node &amp;&amp; _.size(node.ideas) &gt; 0) {
                        					return node.getAttr(&#x27;collapsed&#x27;);
                        				}
                        				return true;
                        			});
                        		}
                        		this.collapse(source, !isCollapsed);
                        	};
                        	this.collapse = function (source, doCollapse) {
                        		analytic(&#x27;collapse:&#x27; + doCollapse, source);
                        		self.isInCollapse = true;
                        		var contextNodeId = getCurrentlySelectedIdeaId(),
                        			contextNode = function () {
                        				return contextNodeId &amp;&amp; currentLayout &amp;&amp; currentLayout.nodes &amp;&amp; currentLayout.nodes[contextNodeId];
                        			},
                        			moveNodes = function (nodes, deltaX, deltaY) {
                        				if (deltaX || deltaY) {
                        					_.each(nodes, function (node) {
                        						node.x += deltaX;
                        						node.y += deltaY;
                        						self.dispatchEvent(&#x27;nodeMoved&#x27;, node, &#x27;scroll&#x27;);
                        					});
                        				}
                        			},
                        			oldContext,
                        			newContext;
                        		oldContext = contextNode();
                        		if (isInputEnabled) {
                        			self.applyToActivated(function (id) {
                        				var node = self.findIdeaById(id);
                        				if (node &amp;&amp; (!doCollapse || (node.ideas &amp;&amp; _.size(node.ideas) &gt; 0))) {
                        					idea.updateAttr(id, &#x27;collapsed&#x27;, doCollapse);
                        				}
                        			});
                        		}
                        		newContext = contextNode();
                        		if (oldContext &amp;&amp; newContext) {
                        			moveNodes(
                        				currentLayout.nodes,
                        				oldContext.x - newContext.x,
                        				oldContext.y - newContext.y
                        			);
                        		}
                        		self.isInCollapse = false;
                        		self.dispatchEvent(&#x27;layoutChangeComplete&#x27;);
                        	};
                        	this.updateStyle = function (source, prop, value) {
                        		/*jslint eqeq:true */
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (isInputEnabled) {
                        			analytic(&#x27;updateStyle:&#x27; + prop, source);
                        			self.applyToActivated(function (id) {
                        				if (self.getStyleForId(id, prop) != value) {
                        					idea.mergeAttrProperty(id, &#x27;style&#x27;, prop, value);
                        				}
                        			});
                        		}
                        	};
                        	this.updateLinkStyle = function (source, ideaIdFrom, ideaIdTo, prop, value) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (isInputEnabled) {
                        			analytic(&#x27;updateLinkStyle:&#x27; + prop, source);
                        			var merged = _.extend({}, idea.getLinkAttr(ideaIdFrom, ideaIdTo, &#x27;style&#x27;));
                        			merged[prop] = value;
                        			idea.updateLinkAttr(ideaIdFrom, ideaIdTo, &#x27;style&#x27;, merged);
                        		}
                        	};
                        	this.addSubIdea = function (source, parentId, initialTitle) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		var target = parentId || currentlySelectedIdeaId, newId;
                        		analytic(&#x27;addSubIdea&#x27;, source);
                        		if (isInputEnabled) {
                        			idea.batch(function () {
                        				ensureNodeIsExpanded(source, target);
                                        if (initialTitle) {
                                            newId = idea.addSubIdea(target, initialTitle);
                                        }
                                        else {
                                            newId = idea.addSubIdea(target);
                                        }
                        			});
                        			if (newId) {
                                        if (initialTitle) {
                                            selectNewIdea(newId);
                                        } else {
                                            editNewIdea(newId);
                                        }
                        			}
                        		}
                        
                        	};
                        	this.insertIntermediate = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (!isInputEnabled || currentlySelectedIdeaId === idea.id) {
                        			return false;
                        		}
                        		var activeNodes = [], newId;
                        		analytic(&#x27;insertIntermediate&#x27;, source);
                        		self.applyToActivated(function (i) { activeNodes.push(i); });
                        		newId = idea.insertIntermediateMultiple(activeNodes);
                        		if (newId) {
                        			editNewIdea(newId);
                        		}
                        	};
                        	this.flip = function (source) {
                        
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;flip&#x27;, source);
                        		if (!isInputEnabled || currentlySelectedIdeaId === idea.id) {
                        			return false;
                        		}
                        		var node = currentLayout.nodes[currentlySelectedIdeaId];
                        		if (!node || node.level !== 2) {
                        			return false;
                        		}
                        
                        		return idea.flip(currentlySelectedIdeaId);
                        	};
                        	this.addSiblingIdeaBefore = function (source) {
                        		var newId, parent, contextRank, newRank;
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;addSiblingIdeaBefore&#x27;, source);
                        		if (!isInputEnabled) {
                        			return false;
                        		}
                        		parent = idea.findParent(currentlySelectedIdeaId) || idea;
                        		idea.batch(function () {
                        			ensureNodeIsExpanded(source, parent.id);
                        			newId = idea.addSubIdea(parent.id);
                        			if (newId &amp;&amp; currentlySelectedIdeaId !== idea.id) {
                        				contextRank = parent.findChildRankById(currentlySelectedIdeaId);
                        				newRank = parent.findChildRankById(newId);
                        				if (contextRank * newRank &lt; 0) {
                        					idea.flip(newId);
                        				}
                        				idea.positionBefore(newId, currentlySelectedIdeaId);
                        			}
                        		});
                        		if (newId) {
                        			editNewIdea(newId);
                        		}
                        	};
                        	this.addSiblingIdea = function (source, optionalNodeId, optionalInitialText) {
                        		var newId, nextId, parent, contextRank, newRank, currentId;
                                currentId = optionalNodeId || currentlySelectedIdeaId;
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;addSiblingIdea&#x27;, source);
                        		if (isInputEnabled) {
                        			parent = idea.findParent(currentId) || idea;
                        			idea.batch(function () {
                        				ensureNodeIsExpanded(source, parent.id);
                                        if (optionalInitialText) {
                                            newId = idea.addSubIdea(parent.id, optionalInitialText);
                                        } else {
                                            newId = idea.addSubIdea(parent.id);
                                        }
                        				if (newId &amp;&amp; currentId !== idea.id) {
                        					nextId = idea.nextSiblingId(currentId);
                        					contextRank = parent.findChildRankById(currentId);
                        					newRank = parent.findChildRankById(newId);
                        					if (contextRank * newRank &lt; 0) {
                        						idea.flip(newId);
                        					}
                        					if (nextId) {
                        						idea.positionBefore(newId, nextId);
                        					}
                        				}
                        			});
                        			if (newId) {
                                        if (optionalInitialText) {
                                            selectNewIdea(newId);
                                        } else {
                                            editNewIdea(newId);
                                        }
                        			}
                        		}
                        	};
                        	this.removeSubIdea = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;removeSubIdea&#x27;, source);
                        		var removed;
                        		if (isInputEnabled) {
                        			self.applyToActivated(function (id) {
                        				/*jslint eqeq:true */
                        				var parent;
                        				if (currentlySelectedIdeaId == id) {
                        					parent = idea.findParent(currentlySelectedIdeaId);
                        					if (parent) {
                        						self.selectNode(parent.id);
                        					}
                        				}
                        				removed  = idea.removeSubIdea(id);
                        			});
                        		}
                        		return removed;
                        	};
                        	this.updateTitle = function (ideaId, title, isNew) {
                        		if (isNew) {
                        			idea.initialiseTitle(ideaId, title);
                        		} else {
                        			idea.updateTitle(ideaId, title);
                        		}
                        	};
                        	this.editNode = function (source, shouldSelectAll, editingNew) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (source) {
                        			analytic(&#x27;editNode&#x27;, source);
                        		}
                        		if (!isInputEnabled) {
                        			return false;
                        		}
                        		var title = currentlySelectedIdea().title;
                        		if (_.include(selectAllTitles, title)) { // === &#x27;Press Space or double-click to edit&#x27;) {
                        			shouldSelectAll = true;
                        		}
                        		self.dispatchEvent(&#x27;nodeEditRequested&#x27;, currentlySelectedIdeaId, shouldSelectAll, !!editingNew);
                        	};
                        	this.editIcon = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (source) {
                        			analytic(&#x27;editIcon&#x27;, source);
                        		}
                        		if (!isInputEnabled) {
                        			return false;
                        		}
                        		self.dispatchEvent(&#x27;nodeIconEditRequested&#x27;, currentlySelectedIdeaId);
                        	};
                        	this.scaleUp = function (source) {
                        		self.scale(source, 1.25);
                        	};
                        	this.scaleDown = function (source) {
                        		self.scale(source, 0.8);
                        	};
                        	this.scale = function (source, scaleMultiplier, zoomPoint) {
                        		if (isInputEnabled) {
                        			self.dispatchEvent(&#x27;mapScaleChanged&#x27;, scaleMultiplier, zoomPoint);
                        			analytic(scaleMultiplier &lt; 1 ? &#x27;scaleDown&#x27; : &#x27;scaleUp&#x27;, source);
                        		}
                        	};
                        	this.move = function (source, deltaX, deltaY) {
                        		if (isInputEnabled) {
                        			self.dispatchEvent(&#x27;mapMoveRequested&#x27;, deltaX, deltaY);
                        			analytic(&#x27;move&#x27;, source);
                        		}
                        	};
                        	this.resetView = function (source) {
                        		if (isInputEnabled) {
                        			self.selectNode(idea.id);
                        			self.dispatchEvent(&#x27;mapViewResetRequested&#x27;);
                        			analytic(&#x27;resetView&#x27;, source);
                        		}
                        
                        	};
                        	this.openAttachment = function (source, nodeId) {
                        		analytic(&#x27;openAttachment&#x27;, source);
                        		nodeId = nodeId || currentlySelectedIdeaId;
                        		var node = currentLayout.nodes[nodeId],
                        			attachment = node &amp;&amp; node.attr &amp;&amp; node.attr.attachment;
                        		if (node) {
                        			self.dispatchEvent(&#x27;attachmentOpened&#x27;, nodeId, attachment);
                        		}
                        	};
                        	this.setAttachment = function (source, nodeId, attachment) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;setAttachment&#x27;, source);
                        		var hasAttachment = !!(attachment &amp;&amp; attachment.content);
                        		idea.updateAttr(nodeId, &#x27;attachment&#x27;, hasAttachment &amp;&amp; attachment);
                        	};
                        	this.addLink = function (source, nodeIdTo) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;addLink&#x27;, source);
                        		idea.addLink(currentlySelectedIdeaId, nodeIdTo);
                        	};
                        	this.selectLink = function (source, link, selectionPoint) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;selectLink&#x27;, source);
                        		if (!link) {
                        			return false;
                        		}
                        		self.dispatchEvent(&#x27;linkSelected&#x27;, link, selectionPoint, idea.getLinkAttr(link.ideaIdFrom, link.ideaIdTo, &#x27;style&#x27;));
                        	};
                        	this.removeLink = function (source, nodeIdFrom, nodeIdTo) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;removeLink&#x27;, source);
                        		idea.removeLink(nodeIdFrom, nodeIdTo);
                        	};
                        
                        	this.toggleAddLinkMode = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (!isInputEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;toggleAddLinkMode&#x27;, source);
                        		isAddLinkMode = !isAddLinkMode;
                        		self.dispatchEvent(&#x27;addLinkModeToggled&#x27;, isAddLinkMode);
                        	};
                        	this.cancelCurrentAction = function (source) {
                        		if (!isInputEnabled) {
                        			return false;
                        		}
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		if (isAddLinkMode) {
                        			this.toggleAddLinkMode(source);
                        		}
                        	};
                        	self.undo = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        
                        		analytic(&#x27;undo&#x27;, source);
                        		var undoSelectionClone = revertSelectionForUndo,
                        			undoActivationClone = revertActivatedForUndo;
                        		if (isInputEnabled) {
                        			idea.undo();
                        			if (undoSelectionClone) {
                        				self.selectNode(undoSelectionClone);
                        			}
                        			if (undoActivationClone) {
                        				setActiveNodes(undoActivationClone);
                        			}
                        
                        		}
                        	};
                        	self.redo = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        
                        		analytic(&#x27;redo&#x27;, source);
                        		if (isInputEnabled) {
                        			idea.redo();
                        		}
                        	};
                        	self.moveRelative = function (source, relativeMovement) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;moveRelative&#x27;, source);
                        		if (isInputEnabled) {
                        			idea.moveRelative(currentlySelectedIdeaId, relativeMovement);
                        		}
                        	};
                        	self.cut = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;cut&#x27;, source);
                        		if (isInputEnabled) {
                        			var activeNodeIds = [], parents = [], firstLiveParent;
                        			self.applyToActivated(function (nodeId) {
                        				activeNodeIds.push(nodeId);
                        				parents.push(idea.findParent(nodeId).id);
                        			});
                        			clipboard.put(idea.cloneMultiple(activeNodeIds));
                        			idea.removeMultiple(activeNodeIds);
                        			firstLiveParent = _.find(parents, idea.findSubIdeaById);
                        			self.selectNode(firstLiveParent || idea.id);
                        		}
                        	};
                        	self.copy = function (source) {
                        		var activeNodeIds = [];
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;copy&#x27;, source);
                        		if (isInputEnabled) {
                        			self.applyToActivated(function (node) {
                        				activeNodeIds.push(node);
                        			});
                        			clipboard.put(idea.cloneMultiple(activeNodeIds));
                        		}
                        	};
                        	self.paste = function (source) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;paste&#x27;, source);
                        		if (isInputEnabled) {
                        			var result = idea.pasteMultiple(currentlySelectedIdeaId, clipboard.get());
                        			if (result &amp;&amp; result[0]) {
                        				self.selectNode(result[0]);
                        			}
                        		}
                        	};
                        	self.pasteStyle = function (source) {
                        		var clipContents = clipboard.get();
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;pasteStyle&#x27;, source);
                        		if (isInputEnabled &amp;&amp; clipContents &amp;&amp; clipContents[0]) {
                        			var pastingStyle = clipContents[0].attr &amp;&amp; clipContents[0].attr.style;
                        			self.applyToActivated(function (id) {
                        				idea.updateAttr(id, &#x27;style&#x27;, pastingStyle);
                        			});
                        		}
                        	};
                        	self.getIcon = function (nodeId) {
                        		var node = currentLayout.nodes[nodeId || currentlySelectedIdeaId];
                        		if (!node) {
                        			return false;
                        		}
                        		return node.attr &amp;&amp; node.attr.icon;
                        	};
                        	self.setIcon = function (source, url, imgWidth, imgHeight, position, nodeId) {
                        		if (!isEditingEnabled) {
                        			return false;
                        		}
                        		analytic(&#x27;setIcon&#x27;, source);
                        		nodeId = nodeId || currentlySelectedIdeaId;
                        		var nodeIdea = self.findIdeaById(nodeId);
                        		if (!nodeIdea) {
                        			return false;
                        		}
                        		if (url) {
                        			idea.updateAttr(nodeId, &#x27;icon&#x27;, {
                        				url: url,
                        				width: imgWidth,
                        				height: imgHeight,
                        				position: position
                        			});
                        		} else if (nodeIdea.title || nodeId === idea.id) {
                        			idea.updateAttr(nodeId, &#x27;icon&#x27;, false);
                        		} else {
                        			idea.removeSubIdea(nodeId);
                        		}
                        	};
                        	self.moveUp = function (source) { self.moveRelative(source, -1); };
                        	self.moveDown = function (source) { self.moveRelative(source, 1); };
                        	self.getSelectedNodeId = function () {
                        		return getCurrentlySelectedIdeaId();
                        	};
                        	self.centerOnNode = function (nodeId) {
                        		if (!currentLayout.nodes[nodeId]) {
                        			idea.startBatch();
                        			_.each(idea.calculatePath(nodeId), function (parent) {
                        				idea.updateAttr(parent.id, &#x27;collapsed&#x27;, false);
                        			});
                        			idea.endBatch();
                        		}
                        		self.dispatchEvent(&#x27;nodeFocusRequested&#x27;, nodeId);
                        		self.selectNode(nodeId);
                        	};
                        	self.search = function (query) {
                        		var result = [];
                        		query = query.toLocaleLowerCase();
                        		idea.traverse(function (contentIdea) {
                        			if (contentIdea.title &amp;&amp; contentIdea.title.toLocaleLowerCase().indexOf(query) &gt;= 0) {
                        				result.push({id: contentIdea.id, title: contentIdea.title});
                        			}
                        		});
                        		return result;
                        	};
                        	//node activation and selection
                        	(function () {
                        			var isRootOrRightHalf = function (id) {
                        				return currentLayout.nodes[id].x &gt;= currentLayout.nodes[idea.id].x;
                        			},
                        			isRootOrLeftHalf = function (id) {
                        				return currentLayout.nodes[id].x &lt;= currentLayout.nodes[idea.id].x;
                        			},
                        			nodesWithIDs = function () {
                        				return _.map(currentLayout.nodes,
                        					function (n, nodeId) {
                        						return _.extend({ id: parseInt(nodeId, 10)}, n);
                        					});
                        			},
                        			applyToNodeLeft = function (source, analyticTag, method) {
                        				var node,
                        					rank,
                        					isRoot = currentlySelectedIdeaId === idea.id,
                        					targetRank = isRoot ? -Infinity : Infinity;
                        				if (!isInputEnabled) {
                        					return;
                        				}
                        				analytic(analyticTag, source);
                        				if (isRootOrLeftHalf(currentlySelectedIdeaId)) {
                        					node = idea.id === currentlySelectedIdeaId ? idea : idea.findSubIdeaById(currentlySelectedIdeaId);
                        					ensureNodeIsExpanded(source, node.id);
                        					for (rank in node.ideas) {
                        						rank = parseFloat(rank);
                        						if ((isRoot &amp;&amp; rank &lt; 0 &amp;&amp; rank &gt; targetRank) || (!isRoot &amp;&amp; rank &gt; 0 &amp;&amp; rank &lt; targetRank)) {
                        							targetRank = rank;
                        						}
                        					}
                        					if (targetRank !== Infinity &amp;&amp; targetRank !== -Infinity) {
                        						method.apply(self, [node.ideas[targetRank].id]);
                        					}
                        				} else {
                        					method.apply(self, [idea.findParent(currentlySelectedIdeaId).id]);
                        				}
                        			},
                        			applyToNodeRight = function (source, analyticTag, method) {
                        				var node, rank, minimumPositiveRank = Infinity;
                        				if (!isInputEnabled) {
                        					return;
                        				}
                        				analytic(analyticTag, source);
                        				if (isRootOrRightHalf(currentlySelectedIdeaId)) {
                        					node = idea.id === currentlySelectedIdeaId ? idea : idea.findSubIdeaById(currentlySelectedIdeaId);
                        					ensureNodeIsExpanded(source, node.id);
                        					for (rank in node.ideas) {
                        						rank = parseFloat(rank);
                        						if (rank &gt; 0 &amp;&amp; rank &lt; minimumPositiveRank) {
                        							minimumPositiveRank = rank;
                        						}
                        					}
                        					if (minimumPositiveRank !== Infinity) {
                        						method.apply(self, [node.ideas[minimumPositiveRank].id]);
                        					}
                        				} else {
                        					method.apply(self, [idea.findParent(currentlySelectedIdeaId).id]);
                        				}
                        			},
                        			applyToNodeUp = function (source, analyticTag, method) {
                        				var previousSibling = idea.previousSiblingId(currentlySelectedIdeaId),
                        					nodesAbove,
                        					closestNode,
                        					currentNode = currentLayout.nodes[currentlySelectedIdeaId];
                        				if (!isInputEnabled) {
                        					return;
                        				}
                        				analytic(analyticTag, source);
                        				if (previousSibling) {
                        					method.apply(self, [previousSibling]);
                        				} else {
                        					if (!currentNode) { return; }
                        					nodesAbove = _.reject(nodesWithIDs(), function (node) {
                        						return node.y &gt;= currentNode.y || Math.abs(node.x - currentNode.x) &gt; horizontalSelectionThreshold;
                        					});
                        					if (_.size(nodesAbove) === 0) {
                        						return;
                        					}
                        					closestNode = _.min(nodesAbove, function (node) {
                        						return Math.pow(node.x - currentNode.x, 2) + Math.pow(node.y - currentNode.y, 2);
                        					});
                        					method.apply(self, [closestNode.id]);
                        				}
                        			},
                        			applyToNodeDown = function (source, analyticTag, method) {
                        				var nextSibling = idea.nextSiblingId(currentlySelectedIdeaId),
                        					nodesBelow,
                        					closestNode,
                        					currentNode = currentLayout.nodes[currentlySelectedIdeaId];
                        				if (!isInputEnabled) {
                        					return;
                        				}
                        				analytic(analyticTag, source);
                        				if (nextSibling) {
                        					method.apply(self, [nextSibling]);
                        				} else {
                        					if (!currentNode) { return; }
                        					nodesBelow = _.reject(nodesWithIDs(), function (node) {
                        						return node.y &lt;= currentNode.y || Math.abs(node.x - currentNode.x) &gt; horizontalSelectionThreshold;
                        					});
                        					if (_.size(nodesBelow) === 0) {
                        						return;
                        					}
                        					closestNode = _.min(nodesBelow, function (node) {
                        						return Math.pow(node.x - currentNode.x, 2) + Math.pow(node.y - currentNode.y, 2);
                        					});
                        					method.apply(self, [closestNode.id]);
                        				}
                        			},
                        			applyFuncs = { &#x27;Left&#x27;: applyToNodeLeft, &#x27;Up&#x27;: applyToNodeUp, &#x27;Down&#x27;: applyToNodeDown, &#x27;Right&#x27;: applyToNodeRight };
                        			self.getActivatedNodeIds = function () {
                        				return activatedNodes.slice(0);
                        			};
                        			self.activateSiblingNodes = function (source) {
                        				var parent = idea.findParent(currentlySelectedIdeaId),
                        					siblingIds;
                        				analytic(&#x27;activateSiblingNodes&#x27;, source);
                        				if (!parent || !parent.ideas) {
                        					return;
                        				}
                        				siblingIds = _.map(parent.ideas, function (child) { return child.id; });
                        				setActiveNodes(siblingIds);
                        			};
                        			self.activateNodeAndChildren = function (source) {
                        				analytic(&#x27;activateNodeAndChildren&#x27;, source);
                        				var contextId = getCurrentlySelectedIdeaId(),
                        					subtree = idea.getSubTreeIds(contextId);
                        				subtree.push(contextId);
                        				setActiveNodes(subtree);
                        			};
                        			_.each([&#x27;Left&#x27;, &#x27;Right&#x27;, &#x27;Up&#x27;, &#x27;Down&#x27;], function (position) {
                        				self[&#x27;activateNode&#x27; + position] = function (source) {
                        					applyFuncs[position](source, &#x27;activateNode&#x27; + position, function (nodeId) {
                        						self.selectNode(nodeId, false, true);
                        					});
                        				};
                        				self[&#x27;selectNode&#x27; + position] = function (source) {
                        					applyFuncs[position](source, &#x27;selectNode&#x27; + position, self.selectNode);
                        				};
                        			});
                        			self.toggleActivationOnNode = function (source, nodeId) {
                        				analytic(&#x27;toggleActivated&#x27;, source);
                        				if (!self.isActivated(nodeId)) {
                        					setActiveNodes([nodeId].concat(activatedNodes));
                        				} else {
                        					setActiveNodes(_.without(activatedNodes, nodeId));
                        				}
                        			};
                        			self.activateNode = function (source, nodeId) {
                        				analytic(&#x27;activateNode&#x27;, source);
                        				if (!self.isActivated(nodeId)) {
                        					activatedNodes.push(nodeId);
                        					self.dispatchEvent(&#x27;activatedNodesChanged&#x27;, [nodeId], []);
                        				}
                        			};
                        			self.activateChildren = function (source) {
                        				analytic(&#x27;activateChildren&#x27;, source);
                        				var context = currentlySelectedIdea();
                        				if (!context || _.isEmpty(context.ideas) || context.getAttr(&#x27;collapsed&#x27;)) {
                        					return;
                        				}
                        				setActiveNodes(idea.getSubTreeIds(context.id));
                        			};
                        			self.activateSelectedNode = function (source) {
                        				analytic(&#x27;activateSelectedNode&#x27;, source);
                        				setActiveNodes([getCurrentlySelectedIdeaId()]);
                        			};
                        			self.isActivated = function (id) {
                        				/*jslint eqeq:true*/
                        				return _.find(activatedNodes, function (activeId) { return id == activeId; });
                        			};
                        			self.applyToActivated = function (toApply) {
                        				idea.batch(function () {_.each(activatedNodes, toApply); });
                        			};
                        			self.everyActivatedIs = function (predicate) {
                        				return _.every(activatedNodes, predicate);
                        			};
                        			self.activateLevel = function (source, level) {
                        				analytic(&#x27;activateLevel&#x27;, source);
                        				var toActivate = _.map(
                        					_.filter(
                        						currentLayout.nodes,
                        						function (node) {
                        							/*jslint eqeq:true*/
                        							return node.level == level;
                        						}
                        					),
                        					function (node) {return node.id; }
                        				);
                        				if (!_.isEmpty(toActivate)) {
                        					setActiveNodes(toActivate);
                        				}
                        			};
                        			self.reactivate = function (layout) {
                        				_.each(layout.nodes, function (node) {
                        					if (_.contains(activatedNodes, node.id)) {
                        						node.activated = true;
                        					}
                        				});
                        				return layout;
                        			};
                        		}());
                        
                        	self.getNodeIdAtPosition = function (x, y) {
                        		var isPointOverNode = function (node) { //move to mapModel candidate
                        				/*jslint eqeq: true*/
                        				return x &gt;= node.x &amp;&amp;
                        					y &gt;= node.y &amp;&amp;
                        					x &lt;= node.x + node.width &amp;&amp;
                        					y &lt;= node.y + node.height;
                        			},
                        			node = _.find(currentLayout.nodes, isPointOverNode);
                        		return node &amp;&amp; node.id;
                        	};
                        	self.autoPosition = function (nodeId) {
                        		return idea.updateAttr(nodeId, &#x27;position&#x27;, false);
                        	};
                        	self.positionNodeAt = function (nodeId, x, y, manualPosition) {
                        		var rootNode = currentLayout.nodes[idea.id],
                        			verticallyClosestNode = {
                        				id: null,
                        				y: Infinity
                        			},
                        			parentIdea = idea.findParent(nodeId),
                        			parentNode = currentLayout.nodes[parentIdea.id],
                        			nodeBeingDragged = currentLayout.nodes[nodeId],
                        			tryFlip = function (rootNode, nodeBeingDragged, nodeDragEndX) {
                        				var flipRightToLeft = rootNode.x &lt; nodeBeingDragged.x &amp;&amp; nodeDragEndX &lt; rootNode.x,
                        					flipLeftToRight = rootNode.x &gt; nodeBeingDragged.x &amp;&amp; rootNode.x &lt; nodeDragEndX;
                        				if (flipRightToLeft || flipLeftToRight) {
                        					return idea.flip(nodeId);
                        				}
                        				return false;
                        			},
                        			maxSequence = 1,
                        			validReposition = function () {
                        				return nodeBeingDragged.level === 2 ||
                        					((nodeBeingDragged.x - parentNode.x) * (x - parentNode.x) &gt; 0);
                        			},
                        			result = false,
                        			xOffset;
                        		idea.startBatch();
                        		if (currentLayout.nodes[nodeId].level === 2) {
                        			result = tryFlip(rootNode, nodeBeingDragged, x);
                        		}
                        		_.each(idea.sameSideSiblingIds(nodeId), function (id) {
                        			var node = currentLayout.nodes[id];
                        			if (y &lt; node.y &amp;&amp; node.y &lt; verticallyClosestNode.y) {
                        				verticallyClosestNode = node;
                        			}
                        		});
                        		if (!manualPosition &amp;&amp; validReposition()) {
                        			self.autoPosition(nodeId);
                        		}
                        		result = idea.positionBefore(nodeId, verticallyClosestNode.id) || result;
                        		if (manualPosition &amp;&amp; validReposition()) {
                        			if (x &lt; parentNode.x) {
                        				xOffset = parentNode.x - x - nodeBeingDragged.width + parentNode.width; /* negative nodes will get flipped so distance is not correct out of the box */
                        			} else {
                        				xOffset = x - parentNode.x;
                        			}
                        			analytic(&#x27;nodeManuallyPositioned&#x27;);
                        			maxSequence = _.max(_.map(parentIdea.ideas, function (i) { return (i.id !== nodeId &amp;&amp; i.attr &amp;&amp; i.attr.position &amp;&amp; i.attr.position[2]) || 0; }));
                        			result = idea.updateAttr(
                        				nodeId,
                        				&#x27;position&#x27;,
                        				[xOffset, y - parentNode.y, maxSequence + 1]
                        			) || result;
                        		}
                        		idea.endBatch();
                        		return result;
                        	};
                        	self.dropNode = function (nodeId, dropTargetId, shiftKey) {
                        		var clone,
                        			parentIdea = idea.findParent(nodeId);
                        		if (dropTargetId === nodeId) {
                        			return false;
                        		}
                        		if (shiftKey) {
                        			clone = idea.clone(nodeId);
                        			if (clone) {
                        				idea.paste(dropTargetId, clone);
                        			}
                        			return false;
                        		}
                        		if (dropTargetId === parentIdea.id) {
                        			return self.autoPosition(nodeId);
                        		} else {
                        			return idea.changeParent(nodeId, dropTargetId);
                        		}
                        	};
                        	self.setLayoutCalculator = function (newCalculator) {
                        		layoutCalculator = newCalculator;
                        	};
                        	self.dropImage =  function (dataUrl, imgWidth, imgHeight, x, y) {
                        		var nodeId,
                        			dropOn = function (ideaId, position) {
                        				var scaleX = Math.min(imgWidth, 300) / imgWidth,
                        					scaleY = Math.min(imgHeight, 300) / imgHeight,
                        					scale = Math.min(scaleX, scaleY),
                        					existing = idea.getAttrById(ideaId, &#x27;icon&#x27;);
                        				self.setIcon(&#x27;drag and drop&#x27;, dataUrl, Math.round(imgWidth * scale), Math.round(imgHeight * scale), (existing &amp;&amp; existing.position) || position, ideaId);
                        			},
                        			addNew = function () {
                        				var newId;
                        				idea.startBatch();
                        				newId = idea.addSubIdea(currentlySelectedIdeaId);
                        				dropOn(newId, &#x27;center&#x27;);
                        				idea.endBatch();
                        				self.selectNode(newId);
                        			};
                        		nodeId = self.getNodeIdAtPosition(x, y);
                        		if (nodeId) {
                        			return dropOn(nodeId, &#x27;left&#x27;);
                        		}
                        		addNew();
                        	};
                        	self.setLabelGenerator = function (labelGenerator) {
                        		currentLabelGenerator = labelGenerator;
                        		self.rebuildRequired();
                        	};
                        	self.getReorderBoundary = function (nodeId) {
                        		var isRoot = function () {
                        				/*jslint eqeq: true*/
                        				return nodeId == idea.id;
                        			},
                        			isFirstLevel = function () {
                        				return parentIdea.id === idea.id;
                        			},
                        			isRightHalf = function (nodeId) {
                        				return currentLayout.nodes[nodeId].x &gt;= currentLayout.nodes[idea.id].x;
                        			},
                        			siblingBoundary = function (siblings, side) {
                        				var tops = _.map(siblings, function (node) {
                        					return node.y;
                        				}),
                        				bottoms = _.map(siblings, function (node) {
                        					return node.y + node.height;
                        				}),
                        				result = {
                        					&#x27;minY&#x27;: _.min(tops) -  reorderMargin - currentLayout.nodes[nodeId].height,
                        					&#x27;maxY&#x27;: _.max(bottoms) +  reorderMargin,
                        					&#x27;margin&#x27;: reorderMargin
                        				};
                        				result.edge = side;
                        				if (side === &#x27;left&#x27;) {
                        					result.x = parentNode.x + parentNode.width + reorderMargin;
                        				} else {
                        					result.x = parentNode.x - reorderMargin;
                        				}
                        				return result;
                        			},
                        			parentBoundary = function (side) {
                        				var result = {
                        					&#x27;minY&#x27;: parentNode.y -  reorderMargin - currentLayout.nodes[nodeId].height,
                        					&#x27;maxY&#x27;: parentNode.y + parentNode.height +  reorderMargin,
                        					&#x27;margin&#x27;: reorderMargin
                        				};
                        				result.edge = side;
                        				if (side === &#x27;left&#x27;) {
                        					result.x = parentNode.x + parentNode.width + reorderMargin;
                        				} else {
                        					result.x = parentNode.x - reorderMargin;
                        				}
                        
                        				return result;
                        			},
                        			otherSideSiblings = function () {
                        				var otherSide = _.map(parentIdea.ideas, function (subIdea) {
                        					return currentLayout.nodes[subIdea.id];
                        				});
                        				otherSide = _.without(otherSide, currentLayout.nodes[nodeId]);
                        				if (!_.isEmpty(sameSide)) {
                        					otherSide = _.difference(otherSide, sameSide);
                        				}
                        				return otherSide;
                        			},
                        			parentIdea,
                        			parentNode,
                        			boundaries = [],
                        			sameSide,
                        			opposite,
                        			primaryEdge,
                        			secondaryEdge;
                        		if (isRoot(nodeId)) {
                        			return false;
                        		}
                        		parentIdea = idea.findParent(nodeId);
                        		parentNode = currentLayout.nodes[parentIdea.id];
                        		primaryEdge = isRightHalf(nodeId) ? &#x27;left&#x27;: &#x27;right&#x27;;
                        		secondaryEdge = isRightHalf(nodeId) ? &#x27;right&#x27;: &#x27;left&#x27;;
                        		sameSide = _.map(idea.sameSideSiblingIds(nodeId), function (id) {
                        			return currentLayout.nodes[id];
                        		});
                        		if (!_.isEmpty(sameSide)) {
                        			boundaries.push(siblingBoundary(sameSide, primaryEdge));
                        		}
                        		boundaries.push(parentBoundary(primaryEdge));
                        		if (isFirstLevel()) {
                        			opposite = otherSideSiblings();
                        			if (!_.isEmpty(opposite)) {
                        				boundaries.push(siblingBoundary(opposite, secondaryEdge));
                        			}
                        			boundaries.push(parentBoundary(secondaryEdge));
                        		}
                        		return boundaries;
                        	};
                            self.focusAndSelect = function (nodeId) {
                               self.selectNode(nodeId);
                               self.dispatchEvent(&#x27;nodeFocusRequested&#x27;, nodeId);
                            };
                        };
                        /*global jQuery*/
                        jQuery.fn.mapToolbarWidget = function (mapModel) {
                        	&#x27;use strict&#x27;;
                        	var clickMethodNames = [&#x27;insertIntermediate&#x27;, &#x27;scaleUp&#x27;, &#x27;scaleDown&#x27;, &#x27;addSubIdea&#x27;, &#x27;editNode&#x27;, &#x27;removeSubIdea&#x27;, &#x27;toggleCollapse&#x27;, &#x27;addSiblingIdea&#x27;, &#x27;undo&#x27;, &#x27;redo&#x27;,
                        			&#x27;copy&#x27;, &#x27;cut&#x27;, &#x27;paste&#x27;, &#x27;resetView&#x27;, &#x27;openAttachment&#x27;, &#x27;toggleAddLinkMode&#x27;, &#x27;activateChildren&#x27;, &#x27;activateNodeAndChildren&#x27;, &#x27;activateSiblingNodes&#x27;, &#x27;editIcon&#x27;],
                        		changeMethodNames = [&#x27;updateStyle&#x27;];
                        	return this.each(function () {
                        		var element = jQuery(this), preventRoundtrip = false;
                        		mapModel.addEventListener(&#x27;nodeSelectionChanged&#x27;, function () {
                        			preventRoundtrip = true;
                        			element.find(&#x27;.updateStyle[data-mm-target-property]&#x27;).val(function () {
                        				return mapModel.getSelectedStyle(jQuery(this).data(&#x27;mm-target-property&#x27;));
                        			}).change();
                        			preventRoundtrip = false;
                        		});
                        		mapModel.addEventListener(&#x27;addLinkModeToggled&#x27;, function () {
                        			element.find(&#x27;.toggleAddLinkMode&#x27;).toggleClass(&#x27;active&#x27;);
                        		});
                        		clickMethodNames.forEach(function (methodName) {
                        			element.find(&#x27;.&#x27; + methodName).click(function () {
                        				if (mapModel[methodName]) {
                        					mapModel[methodName](&#x27;toolbar&#x27;);
                        				}
                        			});
                        		});
                        		changeMethodNames.forEach(function (methodName) {
                        			element.find(&#x27;.&#x27; + methodName).change(function () {
                        				if (preventRoundtrip) {
                        					return;
                        				}
                        				var tool = jQuery(this);
                        				if (tool.data(&#x27;mm-target-property&#x27;)) {
                        					mapModel[methodName](&#x27;toolbar&#x27;, tool.data(&#x27;mm-target-property&#x27;), tool.val());
                        				}
                        			});
                        		});
                        	});
                        };
                        /*global jQuery*/
                        jQuery.fn.linkEditWidget = function (mapModel) {
                        	&#x27;use strict&#x27;;
                        	return this.each(function () {
                        		var element = jQuery(this), currentLink, width, height, colorElement, lineStyleElement, arrowElement;
                        		colorElement = element.find(&#x27;.color&#x27;);
                        		lineStyleElement = element.find(&#x27;.lineStyle&#x27;);
                        		arrowElement = element.find(&#x27;.arrow&#x27;);
                        		mapModel.addEventListener(&#x27;linkSelected&#x27;, function (link, selectionPoint, linkStyle) {
                        			currentLink = link;
                        			element.show();
                        			width = width || element.width();
                        			height = height || element.height();
                        			element.css({
                        				top: (selectionPoint.y - 0.5 * height - 15) + &#x27;px&#x27;,
                        				left: (selectionPoint.x - 0.5 * width - 15) + &#x27;px&#x27;
                        			});
                        			colorElement.val(linkStyle.color).change();
                        			lineStyleElement.val(linkStyle.lineStyle);
                        			arrowElement[linkStyle.arrow ? &#x27;addClass&#x27; : &#x27;removeClass&#x27;](&#x27;active&#x27;);
                        		});
                        		mapModel.addEventListener(&#x27;mapMoveRequested&#x27;, function () {
                        			element.hide();
                        		});
                        		element.find(&#x27;.delete&#x27;).click(function () {
                        			mapModel.removeLink(&#x27;mouse&#x27;, currentLink.ideaIdFrom, currentLink.ideaIdTo);
                        			element.hide();
                        		});
                        		colorElement.change(function () {
                        			mapModel.updateLinkStyle(&#x27;mouse&#x27;, currentLink.ideaIdFrom, currentLink.ideaIdTo, &#x27;color&#x27;, jQuery(this).val());
                        		});
                        		lineStyleElement.find(&#x27;a&#x27;).click(function () {
                        			mapModel.updateLinkStyle(&#x27;mouse&#x27;, currentLink.ideaIdFrom, currentLink.ideaIdTo, &#x27;lineStyle&#x27;, jQuery(this).text());
                        		});
                        		arrowElement.click(function () {
                        			mapModel.updateLinkStyle(&#x27;mouse&#x27;, currentLink.ideaIdFrom, currentLink.ideaIdTo, &#x27;arrow&#x27;, !arrowElement.hasClass(&#x27;active&#x27;));
                        		});
                        		element.mouseleave(element.hide.bind(element));
                        	});
                        };
                        /*global observable, jQuery, FileReader, Image, MAPJS, document, _ */
                        MAPJS.getDataURIAndDimensions = function (src, corsProxyUrl) {
                        	&#x27;use strict&#x27;;
                        	var isDataUri = function (string) {
                        			return (/^data:image/).test(string);
                        		},
                        		convertSrcToDataUri = function (img) {
                        			if (isDataUri(img.src)) {
                        				return img.src;
                        			}
                        			var canvas = document.createElement(&#x27;canvas&#x27;);
                        			canvas.width = img.width;
                        			canvas.height = img.height;
                        			var ctx = canvas.getContext(&#x27;2d&#x27;);
                        			ctx.drawImage(img, 0, 0);
                        			return canvas.toDataURL(&#x27;image/png&#x27;);
                        		},
                        		deferred = jQuery.Deferred(),
                        		domImg = new Image();
                        
                        	domImg.onload = function () {
                        		try {
                        			deferred.resolve({dataUri: convertSrcToDataUri(domImg), width: domImg.width, height: domImg.height});
                        		} catch (e) {
                        			deferred.reject();
                        		}
                        	};
                        	domImg.onerror = function () {
                        		deferred.reject();
                        	};
                        	if (!isDataUri(src)) {
                        		if (corsProxyUrl) {
                        			domImg.crossOrigin = &#x27;Anonymous&#x27;;
                        			src = corsProxyUrl + encodeURIComponent(src);
                        		} else {
                        			deferred.reject(&#x27;no-cors&#x27;);
                        		}
                        	}
                        	domImg.src = src;
                        	return deferred.promise();
                        };
                        MAPJS.ImageInsertController = function (corsProxyUrl, resourceConverter) {
                        	&#x27;use strict&#x27;;
                        	var self = observable(this),
                        		readFileIntoDataUrl = function (fileInfo) {
                        			var loader = jQuery.Deferred(),
                        				fReader = new FileReader();
                        			fReader.onload = function (e) {
                        				loader.resolve(e.target.result);
                        			};
                        			fReader.onerror = loader.reject;
                        			fReader.onprogress = loader.notify;
                        			fReader.readAsDataURL(fileInfo);
                        			return loader.promise();
                        		};
                        	self.insertDataUrl = function (dataUrl, evt) {
                        		self.dispatchEvent(&#x27;imageLoadStarted&#x27;);
                        		MAPJS.getDataURIAndDimensions(dataUrl, corsProxyUrl).then(
                        			function (result) {
                        				var storeUrl = result.dataUri;
                        				if (resourceConverter) {
                        					storeUrl = resourceConverter(storeUrl);
                        				}
                        				self.dispatchEvent(&#x27;imageInserted&#x27;, storeUrl, result.width, result.height, evt);
                        			},
                        			function (reason) {
                        				self.dispatchEvent(&#x27;imageInsertError&#x27;, reason);
                        			}
                        		);
                        	};
                        	self.insertFiles = function (files, evt) {
                        		jQuery.each(files, function (idx, fileInfo) {
                        			if (/^image\//.test(fileInfo.type)) {
                        				jQuery.when(readFileIntoDataUrl(fileInfo)).done(function (dataUrl) { self.insertDataUrl(dataUrl, evt); });
                        			}
                        		});
                        	};
                        	self.insertHtmlContent = function (htmlContent, evt) {
                        		var images = htmlContent.match(/img[^&gt;]*src=&quot;([^&quot;]*)&quot;/);
                        		if (images &amp;&amp; images.length &gt; 0) {
                        			_.each(images.slice(1), function (dataUrl) { self.insertDataUrl(dataUrl, evt); });
                        		}
                        	};
                        };
                        jQuery.fn.imageDropWidget = function (imageInsertController) {
                        	&#x27;use strict&#x27;;
                        	this.on(&#x27;dragenter dragover&#x27;, function (e) {
                        		if (e.originalEvent.dataTransfer) {
                        			return false;
                        		}
                        	}).on(&#x27;drop&#x27;, function (e) {
                        		var dataTransfer = e.originalEvent.dataTransfer,
                        			htmlContent;
                        		e.stopPropagation();
                        		e.preventDefault();
                        		if (dataTransfer &amp;&amp; dataTransfer.files &amp;&amp; dataTransfer.files.length &gt; 0) {
                        			imageInsertController.insertFiles(dataTransfer.files, e.originalEvent);
                        		} else if (dataTransfer) {
                        			htmlContent = dataTransfer.getData(&#x27;text/html&#x27;);
                        			imageInsertController.insertHtmlContent(htmlContent, e.originalEvent);
                        		}
                        	});
                        	return this;
                        };
                        /*global jQuery, Color, _, MAPJS, document, window*/
                        MAPJS.DOMRender = {
                        	svgPixel: &#x27;data:image/svg+xml,&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;1&quot; height=&quot;1&quot;&gt;&lt;/svg&gt;&#x27;,
                        	nodeCacheMark: function (idea, levelOverride) {
                        		&#x27;use strict&#x27;;
                        		return {
                        			title: idea.title,
                        			icon: idea.attr &amp;&amp; idea.attr.icon &amp;&amp; _.pick(idea.attr.icon, &#x27;width&#x27;, &#x27;height&#x27;, &#x27;position&#x27;),
                        			collapsed: idea.attr &amp;&amp; idea.attr.collapsed,
                        			level: idea.level || levelOverride
                        		};
                        	},
                        	dummyTextBox: jQuery(&#x27;&lt;div&gt;&#x27;).addClass(&#x27;mapjs-node&#x27;).css({position: &#x27;absolute&#x27;, visibility: &#x27;hidden&#x27;}),
                        	dimensionProvider: function (idea, level) {
                        		&#x27;use strict&#x27;; /* support multiple stages? */
                        		var textBox = jQuery(document).nodeWithId(idea.id),
                        			translateToPixel = function () {
                        				return MAPJS.DOMRender.svgPixel;
                        			},
                        			result;
                        		if (textBox &amp;&amp; textBox.length &gt; 0) {
                        			if (_.isEqual(textBox.data(&#x27;nodeCacheMark&#x27;), MAPJS.DOMRender.nodeCacheMark(idea, level))) {
                        				return _.pick(textBox.data(), &#x27;width&#x27;, &#x27;height&#x27;);
                        			}
                        		}
                        		textBox = MAPJS.DOMRender.dummyTextBox;
                        		textBox.attr(&#x27;mapjs-level&#x27;, level).appendTo(&#x27;body&#x27;).updateNodeContent(idea, translateToPixel);
                        		result = {
                        			width: textBox.outerWidth(true),
                        			height: textBox.outerHeight(true)
                        		};
                        		textBox.detach();
                        		return result;
                        	},
                        	layoutCalculator: function (contentAggregate) {
                        		&#x27;use strict&#x27;;
                        		return MAPJS.calculateLayout(contentAggregate, MAPJS.DOMRender.dimensionProvider);
                        	},
                        	fixedLayout: false
                        };
                        MAPJS.createSVG = function (tag) {
                        	&#x27;use strict&#x27;;
                        	return jQuery(document.createElementNS(&#x27;http://www.w3.org/2000/svg&#x27;, tag || &#x27;svg&#x27;));
                        };
                        jQuery.fn.getBox = function () {
                        	&#x27;use strict&#x27;;
                        	var domShape = this &amp;&amp; this[0];
                        	if (!domShape) {
                        		return false;
                        	}
                        	return {
                        		top: domShape.offsetTop,
                        		left: domShape.offsetLeft,
                        		width: domShape.offsetWidth,
                        		height: domShape.offsetHeight
                        	};
                        };
                        jQuery.fn.getDataBox = function () {
                        	&#x27;use strict&#x27;;
                        	var domShapeData = this.data();
                        	if (domShapeData &amp;&amp; domShapeData.width &amp;&amp; domShapeData.height) {
                        		return {
                        			top: domShapeData.y,
                        			left: domShapeData.x,
                        			width: domShapeData.width,
                        			height: domShapeData.height
                        		};
                        	}
                        	return this.getBox();
                        };
                        
                        
                        jQuery.fn.animateConnectorToPosition = function (animationOptions, tolerance) {
                        	&#x27;use strict&#x27;;
                        	var element = jQuery(this),
                        		shapeFrom = element.data(&#x27;nodeFrom&#x27;),
                        		shapeTo = element.data(&#x27;nodeTo&#x27;),
                        		fromBox = shapeFrom &amp;&amp; shapeFrom.getDataBox(),
                        		toBox = shapeTo &amp;&amp; shapeTo.getDataBox(),
                        		oldBox = {
                        			from: shapeFrom &amp;&amp; shapeFrom.getBox(),
                        			to: shapeTo &amp;&amp; shapeTo.getBox()
                        		};
                        	tolerance = tolerance || 1;
                        	if (fromBox &amp;&amp; toBox &amp;&amp; oldBox &amp;&amp; oldBox.from.width	=== fromBox.width	&amp;&amp;
                        		oldBox.to.width		=== toBox.width		&amp;&amp;
                        		oldBox.from.height	=== fromBox.height		&amp;&amp;
                        		oldBox.to.height	=== toBox.height		&amp;&amp;
                        		Math.abs(oldBox.from.top - oldBox.to.top - (fromBox.top - toBox.top)) &lt; tolerance &amp;&amp;
                        		Math.abs(oldBox.from.left - oldBox.to.left - (fromBox.left - toBox.left)) &lt; tolerance) {
                        
                        		element.animate({
                        			left: Math.round(Math.min(fromBox.left, toBox.left)),
                        			top: Math.round(Math.min(fromBox.top, toBox.top)),
                        		}, animationOptions);
                        		return true;
                        	}
                        	return false;
                        };
                        jQuery.fn.queueFadeOut = function (options) {
                        	&#x27;use strict&#x27;;
                        	var element = this;
                        	return element.fadeOut(_.extend({
                        		complete: function () {
                        			if (element.is(&#x27;:focus&#x27;)) {
                        				element.parents(&#x27;[tabindex]&#x27;).focus();
                        			}
                        			element.remove();
                        		}
                        	}, options));
                        };
                        jQuery.fn.queueFadeIn = function (options) {
                        	&#x27;use strict&#x27;;
                        	var element = this;
                        	return element
                        		.css(&#x27;opacity&#x27;, 0)
                        		.animate(
                        			{&#x27;opacity&#x27;: 1},
                        			_.extend({ complete: function () { element.css(&#x27;opacity&#x27;, &#x27;&#x27;); }}, options)
                        		);
                        };
                        
                        jQuery.fn.updateStage = function () {
                        	&#x27;use strict&#x27;;
                        	var data = this.data(),
                        		size = {
                        			&#x27;min-width&#x27;: Math.round(data.width - data.offsetX),
                        			&#x27;min-height&#x27;: Math.round(data.height - data.offsetY),
                        			&#x27;width&#x27;: Math.round(data.width - data.offsetX),
                        			&#x27;height&#x27;: Math.round(data.height - data.offsetY),
                        			&#x27;transform-origin&#x27;: &#x27;top left&#x27;,
                        			&#x27;transform&#x27;: &#x27;translate3d(&#x27; + Math.round(data.offsetX) + &#x27;px, &#x27; + Math.round(data.offsetY) + &#x27;px, 0)&#x27;
                        		};
                        	if (data.scale &amp;&amp; data.scale !== 1) {
                        		size.transform = &#x27;scale(&#x27; + data.scale + &#x27;) translate(&#x27; + Math.round(data.offsetX) + &#x27;px, &#x27; + Math.round(data.offsetY) + &#x27;px)&#x27;;
                        	}
                        	this.css(size);
                        	return this;
                        };
                        
                        MAPJS.DOMRender.curvedPath = function (parent, child) {
                        	&#x27;use strict&#x27;;
                        	var horizontalConnector = function (parentX, parentY, parentWidth, parentHeight,
                        				childX, childY, childWidth, childHeight) {
                        			var childHorizontalOffset = parentX &lt; childX ? 0.1 : 0.9,
                        				parentHorizontalOffset = 1 - childHorizontalOffset;
                        			return {
                        				from: {
                        					x: parentX + parentHorizontalOffset * parentWidth,
                        					y: parentY + 0.5 * parentHeight
                        				},
                        				to: {
                        					x: childX + childHorizontalOffset * childWidth,
                        					y: childY + 0.5 * childHeight
                        				},
                        				controlPointOffset: 0
                        			};
                        		},
                        		calculateConnector = function (parent, child) {
                        			var tolerance = 10,
                        				childHorizontalOffset,
                        				childMid = child.top + child.height * 0.5,
                        				parentMid = parent.top + parent.height * 0.5;
                        			if (Math.abs(parentMid - childMid) + tolerance &lt; Math.max(child.height, parent.height * 0.75)) {
                        				return horizontalConnector(parent.left, parent.top, parent.width, parent.height, child.left, child.top, child.width, child.height);
                        			}
                        			childHorizontalOffset = parent.left &lt; child.left ? 0 : 1;
                        			return {
                        				from: {
                        					x: parent.left + 0.5 * parent.width,
                        					y: parent.top + 0.5 * parent.height
                        				},
                        				to: {
                        					x: child.left + childHorizontalOffset * child.width,
                        					y: child.top + 0.5 * child.height
                        				},
                        				controlPointOffset: 0.75
                        			};
                        		},
                        		position = {
                        			left: Math.min(parent.left, child.left),
                        			top: Math.min(parent.top, child.top),
                        		},
                        		calculatedConnector, offset, maxOffset;
                        	position.width = Math.max(parent.left + parent.width, child.left + child.width, position.left + 1) - position.left;
                        	position.height = Math.max(parent.top + parent.height, child.top + child.height, position.top + 1) - position.top;
                        
                        	calculatedConnector = calculateConnector(parent, child);
                        	offset = calculatedConnector.controlPointOffset * (calculatedConnector.from.y - calculatedConnector.to.y);
                        	maxOffset = Math.min(child.height, parent.height) * 1.5;
                        	offset = Math.max(-maxOffset, Math.min(maxOffset, offset));
                        	return {
                        		&#x27;d&#x27;: &#x27;M&#x27; + Math.round(calculatedConnector.from.x - position.left) + &#x27;,&#x27; + Math.round(calculatedConnector.from.y - position.top) +
                        			&#x27;Q&#x27; + Math.round(calculatedConnector.from.x - position.left) + &#x27;,&#x27; + Math.round(calculatedConnector.to.y - offset - position.top) + &#x27; &#x27; + Math.round(calculatedConnector.to.x - position.left) + &#x27;,&#x27; + Math.round(calculatedConnector.to.y - position.top),
                        		// &#x27;conn&#x27;: calculatedConnector,
                        		&#x27;position&#x27;: position
                        	};
                        };
                        MAPJS.DOMRender.straightPath = function (parent, child) {
                        	&#x27;use strict&#x27;;
                        	var calculateConnector = function (parent, child) {
                        		var parentPoints = [
                        			{
                        				x: parent.left + 0.5 * parent.width,
                        				y: parent.top
                        			},
                        			{
                        				x: parent.left + parent.width,
                        				y: parent.top + 0.5 * parent.height
                        			},
                        			{
                        				x: parent.left + 0.5 * parent.width,
                        				y: parent.top + parent.height
                        			},
                        			{
                        				x: parent.left,
                        				y: parent.top + 0.5 * parent.height
                        			}
                        		], childPoints = [
                        			{
                        				x: child.left + 0.5 * child.width,
                        				y: child.top
                        			},
                        			{
                        				x: child.left + child.width,
                        				y: child.top + 0.5 * child.height
                        			},
                        			{
                        				x: child.left + 0.5 * child.width,
                        				y: child.top + child.height
                        			},
                        			{
                        				x: child.left,
                        				y: child.top + 0.5 * child.height
                        			}
                        		], i, j, min = Infinity, bestParent, bestChild, dx, dy, current;
                        		for (i = 0; i &lt; parentPoints.length; i += 1) {
                        			for (j = 0; j &lt; childPoints.length; j += 1) {
                        				dx = parentPoints[i].x - childPoints[j].x;
                        				dy = parentPoints[i].y - childPoints[j].y;
                        				current = dx * dx + dy * dy;
                        				if (current &lt; min) {
                        					bestParent = i;
                        					bestChild = j;
                        					min = current;
                        				}
                        			}
                        		}
                        		return {
                        			from: parentPoints[bestParent],
                        			to: childPoints[bestChild]
                        		};
                        	},
                        	position = {
                        		left: Math.min(parent.left, child.left),
                        		top: Math.min(parent.top, child.top),
                        	},
                        	conn = calculateConnector(parent, child);
                        	position.width = Math.max(parent.left + parent.width, child.left + child.width, position.left + 1) - position.left;
                        	position.height = Math.max(parent.top + parent.height, child.top + child.height, position.top + 1) - position.top;
                        
                        	return {
                        		&#x27;d&#x27;: &#x27;M&#x27; + Math.round(conn.from.x - position.left) + &#x27;,&#x27; + Math.round(conn.from.y - position.top) +
                        				 &#x27;L&#x27; + Math.round(conn.to.x - position.left) + &#x27;,&#x27; + Math.round(conn.to.y - position.top),
                        		&#x27;conn&#x27;: conn,
                        		&#x27;position&#x27;: position
                        	};
                        };
                        
                        MAPJS.DOMRender.nodeConnectorPath = MAPJS.DOMRender.curvedPath;
                        MAPJS.DOMRender.linkConnectorPath = MAPJS.DOMRender.straightPath;
                        
                        jQuery.fn.updateConnector = function (canUseData) {
                        	&#x27;use strict&#x27;;
                        	return jQuery.each(this, function () {
                        		var	element = jQuery(this),
                        			shapeFrom = element.data(&#x27;nodeFrom&#x27;),
                        			shapeTo = element.data(&#x27;nodeTo&#x27;),
                        			connection, pathElement, fromBox, toBox, changeCheck;
                        		if (!shapeFrom || !shapeTo || shapeFrom.length === 0 || shapeTo.length === 0) {
                        			element.hide();
                        			return;
                        		}
                        		if (canUseData) {
                        			fromBox = shapeFrom.getDataBox();
                        			toBox = shapeTo.getDataBox();
                        		} else {
                        			fromBox = shapeFrom.getBox();
                        			toBox = shapeTo.getBox();
                        		}
                        		changeCheck = {from: fromBox, to: toBox};
                        		if (_.isEqual(changeCheck, element.data(&#x27;changeCheck&#x27;))) {
                        			return;
                        		}
                        
                        		element.data(&#x27;changeCheck&#x27;, changeCheck);
                        		connection = MAPJS.DOMRender.nodeConnectorPath(fromBox, toBox);
                        		pathElement = element.find(&#x27;path&#x27;);
                        		element.css(connection.position);
                        		if (pathElement.length === 0) {
                        			pathElement = MAPJS.createSVG(&#x27;path&#x27;).attr(&#x27;class&#x27;, &#x27;mapjs-connector&#x27;).appendTo(element);
                        		}
                        		// if only the relative position changed, do not re-update the curve!!!!
                        		pathElement.attr(&#x27;d&#x27;,
                        			connection.d
                        		);
                        	});
                        };
                        
                        jQuery.fn.updateLink = function () {
                        	&#x27;use strict&#x27;;
                        	return jQuery.each(this, function () {
                        		var	element = jQuery(this),
                        			shapeFrom = element.data(&#x27;nodeFrom&#x27;),
                        			shapeTo = element.data(&#x27;nodeTo&#x27;),
                        			connection,
                        			pathElement = element.find(&#x27;path.mapjs-link&#x27;),
                        			hitElement = element.find(&#x27;path.mapjs-link-hit&#x27;),
                        			arrowElement = element.find(&#x27;path.mapjs-arrow&#x27;),
                        			n = Math.tan(Math.PI / 9),
                        			dashes = {
                        				dashed: &#x27;8, 8&#x27;,
                        				solid: &#x27;&#x27;
                        			},
                        			attrs = _.pick(element.data(), &#x27;lineStyle&#x27;, &#x27;arrow&#x27;, &#x27;color&#x27;),
                        			fromBox, toBox, changeCheck;
                        		if (!shapeFrom || !shapeTo || shapeFrom.length === 0 || shapeTo.length === 0) {
                        			element.hide();
                        			return;
                        		}
                        		fromBox = shapeFrom.getBox();
                        		toBox = shapeTo.getBox();
                        
                        		changeCheck = {from: fromBox, to: toBox, attrs: attrs};
                        		if (_.isEqual(changeCheck, element.data(&#x27;changeCheck&#x27;))) {
                        			return;
                        		}
                        
                        		element.data(&#x27;changeCheck&#x27;, changeCheck);
                        
                        		connection = MAPJS.DOMRender.linkConnectorPath(fromBox, toBox);
                        		element.css(connection.position);
                        
                        		if (pathElement.length === 0) {
                        			pathElement = MAPJS.createSVG(&#x27;path&#x27;).attr(&#x27;class&#x27;, &#x27;mapjs-link&#x27;).appendTo(element);
                        		}
                        		pathElement.attr({
                        			&#x27;d&#x27;: connection.d,
                        			&#x27;stroke-dasharray&#x27;: dashes[attrs.lineStyle]
                        		}).css(&#x27;stroke&#x27;, attrs.color);
                        
                        		if (hitElement.length === 0) {
                        			hitElement = MAPJS.createSVG(&#x27;path&#x27;).attr(&#x27;class&#x27;, &#x27;mapjs-link-hit&#x27;).appendTo(element);
                        		}
                        		hitElement.attr({
                        			&#x27;d&#x27;: connection.d
                        		});
                        
                        		if (attrs.arrow) {
                        			if (arrowElement.length === 0) {
                        				arrowElement = MAPJS.createSVG(&#x27;path&#x27;).attr(&#x27;class&#x27;, &#x27;mapjs-arrow&#x27;).appendTo(element);
                        			}
                        			var a1x, a1y, a2x, a2y, len = 14, iy, m,
                        				dx = connection.conn.to.x - connection.conn.from.x,
                        				dy = connection.conn.to.y - connection.conn.from.y;
                        			if (dx === 0) {
                        				iy = dy &lt; 0 ? -1 : 1;
                        				a1x = connection.conn.to.x + len * Math.sin(n) * iy;
                        				a2x = connection.conn.to.x - len * Math.sin(n) * iy;
                        				a1y = connection.conn.to.y - len * Math.cos(n) * iy;
                        				a2y = connection.conn.to.y - len * Math.cos(n) * iy;
                        			} else {
                        				m = dy / dx;
                        				if (connection.conn.from.x &lt; connection.conn.to.x) {
                        					len = -len;
                        				}
                        				a1x = connection.conn.to.x + (1 - m * n) * len / Math.sqrt((1 + m * m) * (1 + n * n));
                        				a1y = connection.conn.to.y + (m + n) * len / Math.sqrt((1 + m * m) * (1 + n * n));
                        				a2x = connection.conn.to.x + (1 + m * n) * len / Math.sqrt((1 + m * m) * (1 + n * n));
                        				a2y = connection.conn.to.y + (m - n) * len / Math.sqrt((1 + m * m) * (1 + n * n));
                        			}
                        			arrowElement.attr(&#x27;d&#x27;,
                        				&#x27;M&#x27; + Math.round(a1x - connection.position.left) + &#x27;,&#x27; + Math.round(a1y - connection.position.top) +
                        				&#x27;L&#x27; + Math.round(connection.conn.to.x - connection.position.left) + &#x27;,&#x27; + Math.round(connection.conn.to.y - connection.position.top) +
                        				&#x27;L&#x27; + Math.round(a2x - connection.position.left) + &#x27;,&#x27; + Math.round(a2y - connection.position.top) +
                        				&#x27;Z&#x27;)
                        				.css(&#x27;fill&#x27;, attrs.color)
                        				.show();
                        		} else {
                        			arrowElement.hide();
                        		}
                        
                        	});
                        };
                        
                        jQuery.fn.addNodeCacheMark = function (idea) {
                        	&#x27;use strict&#x27;;
                        	this.data(&#x27;nodeCacheMark&#x27;, MAPJS.DOMRender.nodeCacheMark(idea));
                        };
                        
                        jQuery.fn.updateNodeContent = function (nodeContent, resourceTranslator) {
                        	&#x27;use strict&#x27;;
                        	var MAX_URL_LENGTH = 25,
                        		self = jQuery(this),
                        		textSpan = function () {
                        			var span = self.find(&#x27;[data-mapjs-role=title]&#x27;);
                        			if (span.length === 0) {
                        				span = jQuery(&#x27;&lt;span&gt;&#x27;).attr(&#x27;data-mapjs-role&#x27;, &#x27;title&#x27;).appendTo(self);
                        			}
                        			return span;
                        		},
                        		applyLinkUrl = function (title) {
                        			var url = MAPJS.URLHelper.getLink(title),
                        				element = self.find(&#x27;a.mapjs-hyperlink&#x27;);
                        			if (!url) {
                        				element.hide();
                        				return;
                        			}
                        			if (element.length === 0) {
                        				element = jQuery(&#x27;&lt;a target=&quot;_blank&quot; class=&quot;mapjs-hyperlink&quot;&gt;&lt;/a&gt;&#x27;).appendTo(self);
                        			}
                        			element.attr(&#x27;href&#x27;, url).show();
                        		},
                        		applyLabel = function (label) {
                        			var element = self.find(&#x27;.mapjs-label&#x27;);
                        			if (!label &amp;&amp; label !== 0) {
                        				element.hide();
                        				return;
                        			}
                        			if (element.length === 0) {
                        				element = jQuery(&#x27;&lt;span class=&quot;mapjs-label&quot;&gt;&lt;/span&gt;&#x27;).appendTo(self);
                        			}
                        			element.text(label).show();
                        		},
                        		applyAttachment = function () {
                        			var attachment = nodeContent.attr &amp;&amp; nodeContent.attr.attachment,
                        				element = self.find(&#x27;a.mapjs-attachment&#x27;);
                        			if (!attachment) {
                        				element.hide();
                        				return;
                        			}
                        			if (element.length === 0) {
                        				element = jQuery(&#x27;&lt;a href=&quot;#&quot; class=&quot;mapjs-attachment&quot;&gt;&lt;/a&gt;&#x27;).appendTo(self).click(function () {
                        					self.trigger(&#x27;attachment-click&#x27;);
                        				});
                        			}
                        			element.show();
                        		},
                        		updateText = function (title) {
                        			var text = MAPJS.URLHelper.stripLink(title) ||
                        					(title.length &lt; MAX_URL_LENGTH ? title : (title.substring(0, MAX_URL_LENGTH) + &#x27;...&#x27;)),
                        					nodeTextPadding = MAPJS.DOMRender.nodeTextPadding || 11,
                        					element = textSpan(),
                        					domElement = element[0];
                        
                        			element.text(text.trim());
                        			self.data(&#x27;title&#x27;, title);
                        			element.css({&#x27;max-width&#x27;: &#x27;&#x27;, &#x27;min-width&#x27;: &#x27;&#x27;});
                        			if ((domElement.scrollWidth - nodeTextPadding) &gt; domElement.offsetWidth) {
                        				element.css(&#x27;max-width&#x27;, domElement.scrollWidth + &#x27;px&#x27;);
                        			}
                        			else {
                        				var height = domElement.offsetHeight;
                        				element.css(&#x27;min-width&#x27;, element.css(&#x27;max-width&#x27;));
                        				if (domElement.offsetHeight === height) {
                        					element.css(&#x27;min-width&#x27;, &#x27;&#x27;);
                        				}
                        			}
                        		},
                        		setCollapseClass = function () {
                        			if (nodeContent.attr &amp;&amp; nodeContent.attr.collapsed) {
                        				self.addClass(&#x27;collapsed&#x27;);
                        			} else {
                        				self.removeClass(&#x27;collapsed&#x27;);
                        			}
                        		},
                        		foregroundClass = function (backgroundColor) {
                        			/*jslint newcap:true*/
                        			var luminosity = Color(backgroundColor).mix(Color(&#x27;#EEEEEE&#x27;)).luminosity();
                        			if (luminosity &lt; 0.5) {
                        				return &#x27;mapjs-node-dark&#x27;;
                        			}
                        			else if (luminosity &lt; 0.9) {
                        				return &#x27;mapjs-node-light&#x27;;
                        			}
                        			return &#x27;mapjs-node-white&#x27;;
                        		},
                        		setColors = function () {
                        			var fromStyle =	nodeContent.attr &amp;&amp; nodeContent.attr.style &amp;&amp; nodeContent.attr.style.background;
                        			if (fromStyle === &#x27;false&#x27; || fromStyle === &#x27;transparent&#x27;) {
                        				fromStyle = false;
                        			}
                        			self.removeClass(&#x27;mapjs-node-dark mapjs-node-white mapjs-node-light&#x27;);
                        			if (fromStyle) {
                        				self.css(&#x27;background-color&#x27;, fromStyle);
                        				self.addClass(foregroundClass(fromStyle));
                        			} else {
                        				self.css(&#x27;background-color&#x27;, &#x27;&#x27;);
                        			}
                        		},
                        		setIcon = function (icon) {
                        			var textBox = textSpan(),
                        				textHeight,
                        				textWidth,
                        				maxTextWidth,
                        				padding,
                        				selfProps = {
                        					&#x27;min-height&#x27;: &#x27;&#x27;,
                        					&#x27;min-width&#x27;: &#x27;&#x27;,
                        					&#x27;background-image&#x27;: &#x27;&#x27;,
                        					&#x27;background-repeat&#x27;: &#x27;&#x27;,
                        					&#x27;background-size&#x27;: &#x27;&#x27;,
                        					&#x27;background-position&#x27;: &#x27;&#x27;
                        				},
                        				textProps = {
                        					&#x27;margin-top&#x27;: &#x27;&#x27;,
                        					&#x27;margin-left&#x27;: &#x27;&#x27;
                        				};
                        			self.css({padding: &#x27;&#x27;});
                        			if (icon) {
                        				padding = parseInt(self.css(&#x27;padding-left&#x27;), 10);
                        				textHeight = textBox.outerHeight();
                        				textWidth = textBox.outerWidth();
                        				maxTextWidth = parseInt(textBox.css(&#x27;max-width&#x27;), 10);
                        				_.extend(selfProps, {
                        					&#x27;background-image&#x27;: &#x27;url(&quot;&#x27; + (resourceTranslator ? resourceTranslator(icon.url) : icon.url) + &#x27;&quot;)&#x27;,
                        					&#x27;background-repeat&#x27;: &#x27;no-repeat&#x27;,
                        					&#x27;background-size&#x27;: icon.width + &#x27;px &#x27; + icon.height + &#x27;px&#x27;,
                        					&#x27;background-position&#x27;: &#x27;center center&#x27;
                        				});
                        				if (icon.position === &#x27;top&#x27; || icon.position === &#x27;bottom&#x27;) {
                        					if (icon.position === &#x27;top&#x27;) {
                        						selfProps[&#x27;background-position&#x27;] = &#x27;center &#x27; + padding + &#x27;px&#x27;;
                        					} else if (MAPJS.DOMRender.fixedLayout) {
                        						selfProps[&#x27;background-position&#x27;] = &#x27;center &#x27; + (padding + textHeight) + &#x27;px&#x27;;
                        					} else {
                        						selfProps[&#x27;background-position&#x27;] = &#x27;center &#x27; + icon.position + &#x27; &#x27; + padding + &#x27;px&#x27;;
                        					}
                        
                        					selfProps[&#x27;padding-&#x27; + icon.position] = icon.height + (padding * 2);
                        					selfProps[&#x27;min-width&#x27;] = icon.width;
                        					if (icon.width &gt; maxTextWidth) {
                        						textProps[&#x27;margin-left&#x27;] =  (icon.width - maxTextWidth) / 2;
                        					}
                        				}
                        				else if (icon.position === &#x27;left&#x27; || icon.position === &#x27;right&#x27;) {
                        					if (icon.position === &#x27;left&#x27;) {
                        						selfProps[&#x27;background-position&#x27;] = padding + &#x27;px center&#x27;;
                        					} else if (MAPJS.DOMRender.fixedLayout) {
                        						selfProps[&#x27;background-position&#x27;] = (textWidth + (2 * padding)) + &#x27;px center &#x27;;
                        					} else {
                        						selfProps[&#x27;background-position&#x27;] = icon.position + &#x27; &#x27; + padding + &#x27;px center&#x27;;
                        					}
                        
                        					selfProps[&#x27;padding-&#x27; + icon.position] = icon.width + (padding * 2);
                        					if (icon.height &gt; textHeight) {
                        						textProps[&#x27;margin-top&#x27;] =  (icon.height - textHeight) / 2;
                        						selfProps[&#x27;min-height&#x27;] = icon.height;
                        					}
                        				} else {
                        					if (icon.height &gt; textHeight) {
                        						textProps[&#x27;margin-top&#x27;] =  (icon.height - textHeight) / 2;
                        						selfProps[&#x27;min-height&#x27;] = icon.height;
                        					}
                        					selfProps[&#x27;min-width&#x27;] = icon.width;
                        					if (icon.width &gt; maxTextWidth) {
                        						textProps[&#x27;margin-left&#x27;] =  (icon.width - maxTextWidth) / 2;
                        					}
                        				}
                        			}
                        			self.css(selfProps);
                        			textBox.css(textProps);
                        		};
                        	self.attr(&#x27;mapjs-level&#x27;, nodeContent.level);
                        	updateText(nodeContent.title);
                        	applyLinkUrl(nodeContent.title);
                        	applyLabel(nodeContent.label);
                        	applyAttachment();
                        	self.data({&#x27;x&#x27;: Math.round(nodeContent.x), &#x27;y&#x27;: Math.round(nodeContent.y), &#x27;width&#x27;: Math.round(nodeContent.width), &#x27;height&#x27;: Math.round(nodeContent.height), &#x27;nodeId&#x27;: nodeContent.id})
                        		.addNodeCacheMark(nodeContent);
                        	setColors();
                        	setIcon(nodeContent.attr &amp;&amp; nodeContent.attr.icon);
                        	setCollapseClass();
                        	return self;
                        };
                        jQuery.fn.placeCaretAtEnd = function () {
                        	&#x27;use strict&#x27;;
                        	var el = this[0];
                        	if (window.getSelection &amp;&amp; document.createRange) {
                                var range = document.createRange();
                                range.selectNodeContents(el);
                                range.collapse(false);
                                var sel = window.getSelection();
                                sel.removeAllRanges();
                                sel.addRange(range);
                            } else if (document.body.createTextRange) {
                                var textRange = document.body.createTextRange();
                                textRange.moveToElementText(el);
                                textRange.collapse(false);
                                textRange.select();
                            }
                        };
                        jQuery.fn.selectAll = function () {
                        	&#x27;use strict&#x27;;
                        	var el = this[0];
                        	if (window.getSelection &amp;&amp; document.createRange) {
                                var range = document.createRange();
                                range.selectNodeContents(el);
                                var sel = window.getSelection();
                                sel.removeAllRanges();
                                sel.addRange(range);
                            } else if (document.body.createTextRange) {
                                var textRange = document.body.createTextRange();
                                textRange.moveToElementText(el);
                                textRange.select();
                            }
                        };
                        jQuery.fn.innerText = function () {
                          &#x27;use strict&#x27;;
                          var htmlContent = this.html(),
                              containsBr = /&lt;br\/?&gt;/.test(htmlContent);
                          if (!containsBr) {
                            return this.text();
                          }
                          return htmlContent.replace(/&lt;br\/?&gt;/gi,&#x27;\n&#x27;).replace(/(&lt;([^&gt;]+)&gt;)/gi, &#x27;&#x27;);
                        };
                        jQuery.fn.editNode = function (shouldSelectAll) {
                        	&#x27;use strict&#x27;;
                        	var node = this,
                        		textBox = this.find(&#x27;[data-mapjs-role=title]&#x27;),
                        		unformattedText = this.data(&#x27;title&#x27;),
                        		originalText = textBox.text(),
                        		result = jQuery.Deferred(),
                        		clear = function () {
                        			detachListeners();
                        			textBox.css(&#x27;word-break&#x27;, &#x27;&#x27;);
                        			textBox.removeAttr(&#x27;contenteditable&#x27;);
                        			node.shadowDraggable();
                        		},
                        		finishEditing = function () {
                              var content = textBox.innerText();
                        			if (content === unformattedText) {
                        				return cancelEditing();
                        			}
                        			clear();
                        			result.resolve(content);
                        		},
                        		cancelEditing = function () {
                        			clear();
                        			textBox.text(originalText);
                        			result.reject();
                        		},
                        		keyboardEvents = function (e) {
                        			var ENTER_KEY_CODE = 13,
                        				ESC_KEY_CODE = 27,
                        				TAB_KEY_CODE = 9,
                        				S_KEY_CODE = 83,
                        				Z_KEY_CODE = 90;
                        			if (e.shiftKey &amp;&amp; e.which === ENTER_KEY_CODE) {
                        				return; // allow shift+enter to break lines
                        			}
                        			else if (e.which === ENTER_KEY_CODE) {
                        				finishEditing();
                        				e.stopPropagation();
                        			} else if (e.which === ESC_KEY_CODE) {
                        				cancelEditing();
                        				e.stopPropagation();
                        			} else if (e.which === TAB_KEY_CODE || (e.which === S_KEY_CODE &amp;&amp; (e.metaKey || e.ctrlKey))) {
                        				finishEditing();
                        				e.preventDefault(); /* stop focus on another object */
                        			} else if (!e.shiftKey &amp;&amp; e.which === Z_KEY_CODE &amp;&amp; (e.metaKey || e.ctrlKey)) { /* undo node edit on ctrl+z if text was not changed */
                        				if (textBox.text() === unformattedText) {
                        					cancelEditing();
                        				}
                        				e.stopPropagation();
                        			}
                        		},
                        		attachListeners = function () {
                        			textBox.on(&#x27;blur&#x27;, finishEditing).on(&#x27;keydown&#x27;, keyboardEvents);
                        		},
                        		detachListeners = function () {
                        			textBox.off(&#x27;blur&#x27;, finishEditing).off(&#x27;keydown&#x27;, keyboardEvents);
                        		};
                        	attachListeners();
                        	if (unformattedText !== originalText) { /* links or some other potential formatting issues */
                        		textBox.css(&#x27;word-break&#x27;, &#x27;break-all&#x27;);
                        	}
                        	textBox.text(unformattedText).attr(&#x27;contenteditable&#x27;, true).focus();
                        	if (shouldSelectAll) {
                        		textBox.selectAll();
                        	}
                        	else if (unformattedText) {
                        		textBox.placeCaretAtEnd();
                        	}
                        	node.shadowDraggable({disable: true});
                        	return result.promise();
                        };
                        jQuery.fn.updateReorderBounds = function (border, box) {
                        	&#x27;use strict&#x27;;
                        	var element = this;
                        	if (!border) {
                        		element.hide();
                        		return;
                        	}
                        	element.show();
                        	element.attr(&#x27;mapjs-edge&#x27;, border.edge);
                        	element.css({
                        		top: box.y + box.height / 2 - element.height() / 2,
                        		left: border.x - (border.edge === &#x27;left&#x27; ? element.width() : 0)
                        	});
                        
                        };
                        
                        (function () {
                        	&#x27;use strict&#x27;;
                        	var cleanDOMId = function (s) {
                        			return s.replace(/\./g, &#x27;_&#x27;);
                        		},
                        		connectorKey = function (connectorObj) {
                        			return cleanDOMId(&#x27;connector_&#x27; + connectorObj.from + &#x27;_&#x27; + connectorObj.to);
                        		},
                        		linkKey = function (linkObj) {
                        			return cleanDOMId(&#x27;link_&#x27; + linkObj.ideaIdFrom + &#x27;_&#x27; + linkObj.ideaIdTo);
                        		},
                        		nodeKey = function (id) {
                        			return cleanDOMId(&#x27;node_&#x27; + id);
                        		};
                        
                        	jQuery.fn.createNode = function (node) {
                        		return jQuery(&#x27;&lt;div&gt;&#x27;)
                        			.attr({&#x27;id&#x27;: nodeKey(node.id), &#x27;tabindex&#x27;: 0, &#x27;data-mapjs-role&#x27;: &#x27;node&#x27; })
                        			.css({display: &#x27;block&#x27;, position: &#x27;absolute&#x27;})
                        			.addClass(&#x27;mapjs-node&#x27;)
                        			.appendTo(this);
                        	};
                        	jQuery.fn.createConnector = function (connector) {
                        		return MAPJS.createSVG()
                        			.attr({&#x27;id&#x27;: connectorKey(connector), &#x27;data-mapjs-role&#x27;: &#x27;connector&#x27;, &#x27;class&#x27;: &#x27;mapjs-draw-container&#x27;})
                        			.data({&#x27;nodeFrom&#x27;: this.nodeWithId(connector.from), &#x27;nodeTo&#x27;: this.nodeWithId(connector.to)})
                        			.appendTo(this);
                        	};
                        	jQuery.fn.createLink = function (l) {
                        		var defaults = _.extend({color: &#x27;red&#x27;, lineStyle: &#x27;dashed&#x27;}, l.attr &amp;&amp; l.attr.style);
                        		return MAPJS.createSVG()
                        			.attr({
                        				&#x27;id&#x27;: linkKey(l),
                        				&#x27;data-mapjs-role&#x27;: &#x27;link&#x27;,
                        				&#x27;class&#x27;: &#x27;mapjs-draw-container&#x27;
                        			})
                        			.data({&#x27;nodeFrom&#x27;: this.nodeWithId(l.ideaIdFrom), &#x27;nodeTo&#x27;: this.nodeWithId(l.ideaIdTo) })
                        			.data(defaults)
                        			.appendTo(this);
                        	};
                        	jQuery.fn.nodeWithId = function (id) {
                        		return this.find(&#x27;#&#x27; + nodeKey(id));
                        	};
                        	jQuery.fn.findConnector = function (connectorObj) {
                        		return this.find(&#x27;#&#x27; + connectorKey(connectorObj));
                        	};
                        	jQuery.fn.findLink = function (linkObj) {
                        		return this.find(&#x27;#&#x27; + linkKey(linkObj));
                        	};
                        	jQuery.fn.createReorderBounds = function () {
                        		var result = jQuery(&#x27;&lt;div&gt;&#x27;).attr({
                        			&#x27;data-mapjs-role&#x27;: &#x27;reorder-bounds&#x27;,
                        			&#x27;class&#x27;: &#x27;mapjs-reorder-bounds&#x27;
                        		}).hide().css(&#x27;position&#x27;, &#x27;absolute&#x27;).appendTo(this);
                        		return result;
                        	};
                        })();
                        
                        MAPJS.DOMRender.viewController = function (mapModel, stageElement, touchEnabled, imageInsertController, resourceTranslator) {
                        	&#x27;use strict&#x27;;
                        	var viewPort = stageElement.parent(),
                        		connectorsForAnimation = jQuery(),
                        		linksForAnimation = jQuery(),
                        		nodeAnimOptions = { duration: 400, queue: &#x27;nodeQueue&#x27;, easing: &#x27;linear&#x27; },
                        		reorderBounds = jQuery(&#x27;&lt;div&gt;&#x27;);
                        	if (mapModel.isEditingEnabled()) {
                        		reorderBounds = stageElement.createReorderBounds();
                        	}
                        
                        	var getViewPortDimensions = function () {
                        			if (viewPortDimensions) {
                        				return viewPortDimensions;
                        			}
                        			viewPortDimensions =  {
                        				left: viewPort.scrollLeft(),
                        				top: viewPort.scrollTop(),
                        				innerWidth: viewPort.innerWidth(),
                        				innerHeight: viewPort.innerHeight()
                        			};
                        			return viewPortDimensions;
                        		},
                        		stageToViewCoordinates = function (x, y) {
                        			var stage = stageElement.data(),
                        				scrollPosition = getViewPortDimensions();
                        			return  {
                        				x: stage.scale * (x + stage.offsetX) - scrollPosition.left,
                        				y: stage.scale * (y + stage.offsetY) - scrollPosition.top
                        			};
                        		},
                        		viewToStageCoordinates = function (x, y) {
                        			var stage = stageElement.data(),
                        				scrollPosition = getViewPortDimensions();
                        			return {
                        				x: (scrollPosition.left + x) / stage.scale - stage.offsetX,
                        				y: (scrollPosition.top + y) / stage.scale - stage.offsetY
                        			};
                        		},
                        		updateScreenCoordinates = function () {
                        			var element = jQuery(this);
                        			element.css({
                        				&#x27;left&#x27;: element.data(&#x27;x&#x27;),
                        				&#x27;top&#x27; : element.data(&#x27;y&#x27;),
                        			}).trigger(&#x27;mapjs:move&#x27;);
                        		},
                        		animateToPositionCoordinates = function () {
                        			var element = jQuery(this);
                        			element.clearQueue(nodeAnimOptions.queue).animate({
                        				&#x27;left&#x27;: element.data(&#x27;x&#x27;),
                        				&#x27;top&#x27; : element.data(&#x27;y&#x27;),
                        				&#x27;opacity&#x27;: 1 /* previous animation can be cancelled with clearqueue, so ensure it gets visible */
                        			}, _.extend({
                        				complete: function () {
                        					element.css(&#x27;opacity&#x27;, &#x27;&#x27;);
                        					element.each(updateScreenCoordinates);
                        				},
                        			}, nodeAnimOptions)).trigger(&#x27;mapjs:animatemove&#x27;);
                        		},
                        		ensureSpaceForPoint = function (x, y) {/* in stage coordinates */
                        			var stage = stageElement.data(),
                        				dirty = false;
                        			if (x &lt; -1 * stage.offsetX) {
                        				stage.width =  stage.width - stage.offsetX - x;
                        				stage.offsetX = -1 * x;
                        				dirty = true;
                        			}
                        			if (y &lt; -1 * stage.offsetY) {
                        				stage.height = stage.height - stage.offsetY - y;
                        				stage.offsetY = -1 * y;
                        				dirty = true;
                        			}
                        			if (x &gt; stage.width - stage.offsetX) {
                        				stage.width = stage.offsetX + x;
                        				dirty = true;
                        			}
                        			if (y &gt; stage.height - stage.offsetY) {
                        				stage.height = stage.offsetY + y;
                        				dirty = true;
                        			}
                        			if (dirty) {
                        				stageElement.updateStage();
                        			}
                        		},
                        		ensureSpaceForNode = function () {
                        			return jQuery(this).each(function () {
                        				var node = jQuery(this).data(),
                        					margin = MAPJS.DOMRender.stageMargin || {top: 0, left: 0, bottom: 0, right: 0};
                        				/* sequence of calculations is important because maxX and maxY take into consideration the new offsetX snd offsetY */
                        				ensureSpaceForPoint(node.x - margin.left, node.y - margin.top);
                        				ensureSpaceForPoint(node.x + node.width + margin.right, node.y + node.height + margin.bottom);
                        			});
                        		},
                        		centerViewOn = function (x, y, animate)/*in the stage coordinate system*/ {
                        			var stage = stageElement.data(),
                        				viewPortCenter = {
                        					x: viewPort.innerWidth() / 2,
                        					y: viewPort.innerHeight() / 2
                        				},
                        				newLeftScroll, newTopScroll,
                                margin = MAPJS.DOMRender.stageVisibilityMargin || {top: 0, left: 0, bottom: 0, right: 0};
                        			ensureSpaceForPoint(x - viewPortCenter.x / stage.scale, y - viewPortCenter.y / stage.scale);
                        			ensureSpaceForPoint(x + viewPortCenter.x / stage.scale - margin.left, y + viewPortCenter.y / stage.scale - margin.top);
                        
                        			newLeftScroll = stage.scale * (x + stage.offsetX) - viewPortCenter.x;
                        			newTopScroll = stage.scale * (y + stage.offsetY) - viewPortCenter.y;
                        			viewPort.finish();
                        			if (animate) {
                        				viewPort.animate({
                        					scrollLeft: newLeftScroll,
                        					scrollTop: newTopScroll
                        				}, {
                        					duration: 400
                        				});
                        			} else {
                        				viewPort.scrollLeft(newLeftScroll);
                        				viewPort.scrollTop(newTopScroll);
                        			}
                        		},
                        		stagePointAtViewportCenter = function () {
                        			return viewToStageCoordinates(viewPort.innerWidth() / 2, viewPort.innerHeight() / 2);
                        		},
                        		ensureNodeVisible = function (domElement) {
                        			if (!domElement || domElement.length === 0) {
                        				return;
                        			}
                        			viewPort.finish();
                        			var node = domElement.data(),
                        				nodeTopLeft = stageToViewCoordinates(node.x, node.y),
                        				nodeBottomRight = stageToViewCoordinates(node.x + node.width, node.y + node.height),
                        				animation = {},
                        				margin = MAPJS.DOMRender.stageVisibilityMargin || {top: 10, left: 10, bottom: 10, right: 10};
                        			if ((nodeTopLeft.x - margin.left) &lt; 0) {
                        				animation.scrollLeft = viewPort.scrollLeft() + nodeTopLeft.x - margin.left;
                        			} else if ((nodeBottomRight.x + margin.right) &gt; viewPort.innerWidth()) {
                        				animation.scrollLeft = viewPort.scrollLeft() + nodeBottomRight.x - viewPort.innerWidth() + margin.right;
                        			}
                        			if ((nodeTopLeft.y - margin.top) &lt; 0) {
                        				animation.scrollTop = viewPort.scrollTop() + nodeTopLeft.y - margin.top;
                        			} else if ((nodeBottomRight.y + margin.bottom) &gt; viewPort.innerHeight()) {
                        				animation.scrollTop = viewPort.scrollTop() + nodeBottomRight.y - viewPort.innerHeight() + margin.bottom;
                        			}
                        			if (!_.isEmpty(animation)) {
                        				viewPort.animate(animation, {duration: 100});
                        			}
                        		},
                        		viewportCoordinatesForPointEvent = function (evt) {
                        			var dropPosition = (evt &amp;&amp; evt.gesture &amp;&amp; evt.gesture.center) || evt,
                        				vpOffset = viewPort.offset(),
                        				result;
                        			if (dropPosition) {
                        				result = {
                        					x: dropPosition.pageX - vpOffset.left,
                        					y: dropPosition.pageY -  vpOffset.top
                        				};
                        				if (result.x &gt;= 0 &amp;&amp; result.x &lt;= viewPort.innerWidth() &amp;&amp; result.y &gt;= 0 &amp;&amp; result.y &lt;= viewPort.innerHeight()) {
                        					return result;
                        				}
                        			}
                        		},
                        		stagePositionForPointEvent = function (evt) {
                        			var viewportDropCoordinates = viewportCoordinatesForPointEvent(evt);
                        			if (viewportDropCoordinates) {
                        				return viewToStageCoordinates(viewportDropCoordinates.x, viewportDropCoordinates.y);
                        			}
                        		},
                        		clearCurrentDroppable = function () {
                        			if (currentDroppable || currentDroppable === false) {
                        				jQuery(&#x27;.mapjs-node&#x27;).removeClass(&#x27;droppable&#x27;);
                        				currentDroppable = undefined;
                        			}
                        		},
                        		showDroppable = function (nodeId) {
                        			stageElement.nodeWithId(nodeId).addClass(&#x27;droppable&#x27;);
                        			currentDroppable = nodeId;
                        		},
                        		currentDroppable = false,
                        		viewPortDimensions,
                        		withinReorderBoundary = function (boundaries, box) {
                        			if (_.isEmpty(boundaries)) {
                        				return false;
                        			}
                        			if (!box) {
                        				return false;
                        			}
                        			var closeTo = function (reorderBoundary) {
                        					var nodeX = box.x;
                        					if (reorderBoundary.edge === &#x27;right&#x27;) {
                        						nodeX += box.width;
                        					}
                        					return Math.abs(nodeX - reorderBoundary.x) &lt; reorderBoundary.margin * 2 &amp;&amp;
                        						box.y &lt; reorderBoundary.maxY &amp;&amp;
                        						box.y &gt; reorderBoundary.minY;
                        				};
                        			return _.find(boundaries, closeTo);
                        		};
                        	viewPort.on(&#x27;scroll&#x27;, function () { viewPortDimensions = undefined; });
                        	if (imageInsertController) {
                        		imageInsertController.addEventListener(&#x27;imageInserted&#x27;, function (dataUrl, imgWidth, imgHeight, evt) {
                        			var point = stagePositionForPointEvent(evt);
                        			mapModel.dropImage(dataUrl, imgWidth, imgHeight, point &amp;&amp; point.x, point &amp;&amp; point.y);
                        		});
                        	}
                        	mapModel.addEventListener(&#x27;nodeCreated&#x27;, function (node) {
                        		var currentReorderBoundary,
                        			element = stageElement.createNode(node)
                        			.queueFadeIn(nodeAnimOptions)
                        			.updateNodeContent(node, resourceTranslator)
                        			.on(&#x27;tap&#x27;, function (evt) {
                        
                        				var realEvent = (evt.gesture &amp;&amp; evt.gesture.srcEvent) || evt;
                        				if (realEvent.button &amp;&amp; realEvent.button !== -1) {
                        					return;
                        				}
                        				mapModel.clickNode(node.id, realEvent);
                        				if (evt) {
                        					evt.stopPropagation();
                        				}
                        				if (evt &amp;&amp; evt.gesture) {
                        					evt.gesture.stopPropagation();
                        				}
                        
                        			})
                        			.on(&#x27;doubletap&#x27;, function (event) {
                        				if (event) {
                        					event.stopPropagation();
                        					if (event.gesture) {
                        						event.gesture.stopPropagation();
                        					}
                        				}
                        				if (!mapModel.isEditingEnabled()) {
                        					mapModel.toggleCollapse(&#x27;mouse&#x27;);
                        					return;
                        				}
                        				mapModel.editNode(&#x27;mouse&#x27;);
                        			})
                        			.on(&#x27;attachment-click&#x27;, function () {
                        				mapModel.openAttachment(&#x27;mouse&#x27;, node.id);
                        			})
                        			.each(ensureSpaceForNode)
                        			.each(updateScreenCoordinates)
                        			.on(&#x27;mm:start-dragging mm:start-dragging-shadow&#x27;, function () {
                        				mapModel.selectNode(node.id);
                        				currentReorderBoundary = mapModel.getReorderBoundary(node.id);
                        				element.addClass(&#x27;dragging&#x27;);
                        			})
                        			.on(&#x27;mm:drag&#x27;, function (evt) {
                        				var dropCoords = stagePositionForPointEvent(evt),
                        					currentPosition = evt.currentPosition &amp;&amp; stagePositionForPointEvent({pageX: evt.currentPosition.left, pageY: evt.currentPosition.top}),
                        					nodeId,
                        					hasShift = evt &amp;&amp; evt.gesture &amp;&amp; evt.gesture.srcEvent &amp;&amp; evt.gesture.srcEvent.shiftKey;
                        				if (!dropCoords) {
                        					clearCurrentDroppable();
                        					return;
                        				}
                        
                        				nodeId = mapModel.getNodeIdAtPosition(dropCoords.x, dropCoords.y);
                        				if (!hasShift &amp;&amp; !nodeId &amp;&amp; currentPosition) {
                        					currentPosition.width = element.outerWidth();
                        					currentPosition.height = element.outerHeight();
                        					var border = withinReorderBoundary(currentReorderBoundary, currentPosition);
                        					reorderBounds.updateReorderBounds(border, currentPosition);
                        				} else {
                        					reorderBounds.hide();
                        				}
                        				if (!nodeId || nodeId === node.id) {
                        					clearCurrentDroppable();
                        				}
                        				else if (nodeId !== currentDroppable) {
                        					clearCurrentDroppable();
                        					if (nodeId) {
                        						showDroppable(nodeId);
                        					}
                        				}
                        			})
                        			.on(&#x27;contextmenu&#x27;, function (event) {
                        				// ugly ugly ugly!
                        				mapModel.selectNode(node.id);
                        				mapModel.dispatchEvent(&#x27;contextMenuRequested&#x27;, node.id, event.pageX, event.pageY);
                        				event.preventDefault();
                        				return false;
                        			})
                        			.on(&#x27;mm:stop-dragging&#x27;, function (evt) {
                        				element.removeClass(&#x27;dragging&#x27;);
                        				reorderBounds.hide();
                        				var isShift = evt &amp;&amp; evt.gesture &amp;&amp; evt.gesture.srcEvent &amp;&amp; evt.gesture.srcEvent.shiftKey,
                        					stageDropCoordinates = stagePositionForPointEvent(evt),
                        					nodeAtDrop, finalPosition, dropResult, manualPosition;
                        				clearCurrentDroppable();
                        				if (!stageDropCoordinates) {
                        					return;
                        				}
                        				nodeAtDrop = mapModel.getNodeIdAtPosition(stageDropCoordinates.x, stageDropCoordinates.y);
                        				finalPosition = stagePositionForPointEvent({pageX: evt.finalPosition.left, pageY: evt.finalPosition.top});
                        				if (nodeAtDrop &amp;&amp; nodeAtDrop !== node.id) {
                        					dropResult = mapModel.dropNode(node.id, nodeAtDrop, !!isShift);
                        				} else if (node.level &gt; 1) {
                        					finalPosition.width = element.outerWidth();
                        					finalPosition.height = element.outerHeight();
                        					manualPosition = (!!isShift) || !withinReorderBoundary(currentReorderBoundary, finalPosition);
                        					dropResult = mapModel.positionNodeAt(node.id, finalPosition.x, finalPosition.y, manualPosition);
                        				} else if (node.level === 1 &amp;&amp; evt.gesture) {
                        					var vpCenter = stagePointAtViewportCenter();
                        					vpCenter.x -= evt.gesture.deltaX || 0;
                        					vpCenter.y -= evt.gesture.deltaY || 0;
                        					centerViewOn(vpCenter.x, vpCenter.y, true);
                        					dropResult = true;
                        				} else {
                        					dropResult = false;
                        				}
                        				return dropResult;
                        			})
                        			.on(&#x27;mm:cancel-dragging&#x27;, function () {
                        				clearCurrentDroppable();
                        				element.removeClass(&#x27;dragging&#x27;);
                        				reorderBounds.hide();
                        			});
                        		if (touchEnabled) {
                        			element.on(&#x27;hold&#x27;, function (evt) {
                        				var realEvent = (evt.gesture &amp;&amp; evt.gesture.srcEvent) || evt;
                        				mapModel.clickNode(node.id, realEvent);
                        				mapModel.dispatchEvent(&#x27;contextMenuRequested&#x27;, node.id, evt.gesture.center.pageX, evt.gesture.center.pageY);
                        				evt.preventDefault();
                        				if (evt.gesture) {
                        					evt.gesture.preventDefault();
                        					evt.gesture.stopPropagation();
                        				}
                        				return false;
                        			});
                        		}
                        		element.css(&#x27;min-width&#x27;, element.css(&#x27;width&#x27;));
                        		if (mapModel.isEditingEnabled()) {
                        			element.shadowDraggable();
                        		}
                        	});
                        	mapModel.addEventListener(&#x27;nodeSelectionChanged&#x27;, function (ideaId, isSelected) {
                        		var node = stageElement.nodeWithId(ideaId);
                        		if (isSelected) {
                        			node.addClass(&#x27;selected&#x27;);
                        			ensureNodeVisible(node);
                        		} else {
                        			node.removeClass(&#x27;selected&#x27;);
                        		}
                        	});
                        	mapModel.addEventListener(&#x27;nodeRemoved&#x27;, function (node) {
                        		stageElement.nodeWithId(node.id).queueFadeOut(nodeAnimOptions);
                        	});
                        	mapModel.addEventListener(&#x27;nodeMoved&#x27;, function (node /*, reason*/) {
                        		var	currentViewPortDimensions = getViewPortDimensions(),
                        			nodeDom = stageElement.nodeWithId(node.id).data({
                        				&#x27;x&#x27;: Math.round(node.x),
                        				&#x27;y&#x27;: Math.round(node.y)
                        			}).each(ensureSpaceForNode),
                        			screenTopLeft = stageToViewCoordinates(Math.round(node.x), Math.round(node.y)),
                        			screenBottomRight = stageToViewCoordinates(Math.round(node.x + node.width), Math.round(node.y + node.height));
                        		if (screenBottomRight.x &lt; 0 || screenBottomRight.y &lt; 0 || screenTopLeft.x &gt; currentViewPortDimensions.innerWidth || screenTopLeft.y &gt; currentViewPortDimensions.innerHeight) {
                        			nodeDom.each(updateScreenCoordinates);
                        		} else {
                        			nodeDom.each(animateToPositionCoordinates);
                        		}
                        	});
                        	mapModel.addEventListener(&#x27;nodeTitleChanged nodeAttrChanged nodeLabelChanged&#x27;, function (n) {
                        		stageElement.nodeWithId(n.id).updateNodeContent(n, resourceTranslator);
                        	});
                        	mapModel.addEventListener(&#x27;connectorCreated&#x27;, function (connector) {
                        		var element = stageElement.createConnector(connector).queueFadeIn(nodeAnimOptions).updateConnector(true);
                        		stageElement.nodeWithId(connector.from).add(stageElement.nodeWithId(connector.to))
                        			.on(&#x27;mapjs:move&#x27;, function () { element.updateConnector(true); })
                        			.on(&#x27;mm:drag&#x27;, function () { element.updateConnector(); })
                        			.on(&#x27;mapjs:animatemove&#x27;, function () { connectorsForAnimation = connectorsForAnimation.add(element); });
                        	});
                        	mapModel.addEventListener(&#x27;connectorRemoved&#x27;, function (connector) {
                        		stageElement.findConnector(connector).queueFadeOut(nodeAnimOptions);
                        	});
                        	mapModel.addEventListener(&#x27;linkCreated&#x27;, function (l) {
                        		var link = stageElement.createLink(l).queueFadeIn(nodeAnimOptions).updateLink();
                        		link.find(&#x27;.mapjs-link-hit&#x27;).on(&#x27;tap&#x27;, function (event) {
                        			mapModel.selectLink(&#x27;mouse&#x27;, l, { x: event.gesture.center.pageX, y: event.gesture.center.pageY });
                        			event.stopPropagation();
                        			event.gesture.stopPropagation();
                        		});
                        		stageElement.nodeWithId(l.ideaIdFrom).add(stageElement.nodeWithId(l.ideaIdTo))
                        			.on(&#x27;mapjs:move mm:drag&#x27;, function () { link.updateLink(); })
                        			.on(&#x27;mapjs:animatemove&#x27;, function () { linksForAnimation = linksForAnimation.add(link); });
                        
                        	});
                        	mapModel.addEventListener(&#x27;linkRemoved&#x27;, function (l) {
                        		stageElement.findLink(l).queueFadeOut(nodeAnimOptions);
                        	});
                        	mapModel.addEventListener(&#x27;mapScaleChanged&#x27;, function (scaleMultiplier /*, zoomPoint */) {
                        		var currentScale = stageElement.data(&#x27;scale&#x27;),
                        			targetScale = Math.max(Math.min(currentScale * scaleMultiplier, 5), 0.2),
                        			currentCenter = stagePointAtViewportCenter();
                        		if (currentScale === targetScale) {
                        			return;
                        		}
                        		stageElement.data(&#x27;scale&#x27;, targetScale).updateStage();
                        		centerViewOn(currentCenter.x, currentCenter.y);
                        	});
                        	mapModel.addEventListener(&#x27;nodeFocusRequested&#x27;, function (ideaId)  {
                        		var node = stageElement.nodeWithId(ideaId).data(),
                        			nodeCenterX = node.x + node.width / 2,
                        			nodeCenterY = node.y + node.height / 2;
                        		if (stageElement.data(&#x27;scale&#x27;) !== 1) {
                        			stageElement.data(&#x27;scale&#x27;, 1).updateStage();
                        		}
                        		centerViewOn(nodeCenterX, nodeCenterY, true);
                        	});
                        	mapModel.addEventListener(&#x27;mapViewResetRequested&#x27;, function () {
                        		stageElement.data({&#x27;scale&#x27;: 1, &#x27;height&#x27;: 0, &#x27;width&#x27;: 0, &#x27;offsetX&#x27;: 0, &#x27;offsetY&#x27;: 0}).updateStage();
                        		stageElement.children().andSelf().finish(nodeAnimOptions.queue);
                        		jQuery(stageElement).find(&#x27;.mapjs-node&#x27;).each(ensureSpaceForNode);
                        		jQuery(stageElement).find(&#x27;[data-mapjs-role=connector]&#x27;).updateConnector(true);
                        		jQuery(stageElement).find(&#x27;[data-mapjs-role=link]&#x27;).updateLink();
                        		centerViewOn(0, 0);
                        		viewPort.focus();
                        	});
                        	mapModel.addEventListener(&#x27;layoutChangeStarting&#x27;, function () {
                        		viewPortDimensions = undefined;
                        		stageElement.children().finish(nodeAnimOptions.queue);
                        		stageElement.finish(nodeAnimOptions.queue);
                        	});
                        	mapModel.addEventListener(&#x27;layoutChangeComplete&#x27;, function () {
                        		var connectorGroupClone = jQuery(), linkGroupClone = jQuery();
                        
                        		connectorsForAnimation.each(function () {
                        			if (!jQuery(this).animateConnectorToPosition(nodeAnimOptions, 2)) {
                        				connectorGroupClone = connectorGroupClone.add(this);
                        			}
                        		});
                        		linksForAnimation.each(function () {
                        			if (!jQuery(this).animateConnectorToPosition(nodeAnimOptions, 2)) {
                        				linkGroupClone = linkGroupClone.add(this);
                        			}
                        		});
                        		connectorsForAnimation = jQuery();
                        		linksForAnimation = jQuery();
                        		stageElement.animate({&#x27;opacity&#x27;: 1}, _.extend({
                        			progress: function () {
                        				connectorGroupClone.updateConnector();
                        				linkGroupClone.updateLink();
                        			}
                        		}, nodeAnimOptions));
                        		ensureNodeVisible(stageElement.nodeWithId(mapModel.getCurrentlySelectedIdeaId()));
                        		stageElement.children().dequeue(nodeAnimOptions.queue);
                        		stageElement.dequeue(nodeAnimOptions.queue);
                        	});
                        
                        	/* editing */
                        
                        	mapModel.addEventListener(&#x27;nodeEditRequested&#x27;, function (nodeId, shouldSelectAll, editingNew) {
                        		var editingElement = stageElement.nodeWithId(nodeId);
                        		mapModel.setInputEnabled(false);
                        		viewPort.finish(); /* close any pending animations */
                        		editingElement.editNode(shouldSelectAll).done(
                        			function (newText) {
                        				mapModel.setInputEnabled(true);
                        				mapModel.updateTitle(nodeId, newText, editingNew);
                        				editingElement.focus();
                        
                        			}).fail(function () {
                        				mapModel.setInputEnabled(true);
                        				if (editingNew) {
                        					mapModel.undo(&#x27;internal&#x27;);
                        				}
                        				editingElement.focus();
                        			});
                        	});
                        	mapModel.addEventListener(&#x27;addLinkModeToggled&#x27;, function (isOn) {
                        		if (isOn) {
                        			stageElement.addClass(&#x27;mapjs-add-link&#x27;);
                        		} else {
                        			stageElement.removeClass(&#x27;mapjs-add-link&#x27;);
                        		}
                        	});
                        	mapModel.addEventListener(&#x27;linkAttrChanged&#x27;, function (l) {
                        		var  attr = _.extend({arrow: false}, l.attr &amp;&amp; l.attr.style);
                        		stageElement.findLink(l).data(attr).updateLink();
                        	});
                        
                        	mapModel.addEventListener(&#x27;activatedNodesChanged&#x27;, function (activatedNodes, deactivatedNodes) {
                        		_.each(activatedNodes, function (nodeId) {
                        			stageElement.nodeWithId(nodeId).addClass(&#x27;activated&#x27;);
                        		});
                        		_.each(deactivatedNodes, function (nodeId) {
                        			stageElement.nodeWithId(nodeId).removeClass(&#x27;activated&#x27;);
                        		});
                        	});
                        };
                        
                        /*jslint nomen: true, newcap: true, browser: true*/
                        /*global MAPJS, $, _, jQuery*/
                        
                        jQuery.fn.scrollWhenDragging = function (scrollPredicate) {
                        	/*jslint newcap:true*/
                        	&#x27;use strict&#x27;;
                        	return this.each(function () {
                        		var element = $(this),
                        			dragOrigin;
                        		element.on(&#x27;dragstart&#x27;, function () {
                        			if (scrollPredicate()) {
                        				dragOrigin = {
                        					top: element.scrollTop(),
                        					left: element.scrollLeft()
                        				};
                        			}
                        		}).on(&#x27;drag&#x27;, function (e) {
                        			if (e.gesture &amp;&amp; dragOrigin) {
                        				element.scrollTop(dragOrigin.top - e.gesture.deltaY);
                        				element.scrollLeft(dragOrigin.left - e.gesture.deltaX);
                        			}
                        		}).on(&#x27;dragend&#x27;, function () {
                        			dragOrigin = undefined;
                        		});
                        	});
                        };
                        $.fn.domMapWidget = function (activityLog, mapModel, touchEnabled, imageInsertController, dragContainer, resourceTranslator, centerSelectedNodeOnOrientationChange) {
                        	&#x27;use strict&#x27;;
                        	var hotkeyEventHandlers = {
                        			&#x27;return&#x27;: &#x27;addSiblingIdea&#x27;,
                        			&#x27;shift+return&#x27;: &#x27;addSiblingIdeaBefore&#x27;,
                        			&#x27;del backspace&#x27;: &#x27;removeSubIdea&#x27;,
                        			&#x27;tab insert&#x27;: &#x27;addSubIdea&#x27;,
                        			&#x27;left&#x27;: &#x27;selectNodeLeft&#x27;,
                        			&#x27;up&#x27;: &#x27;selectNodeUp&#x27;,
                        			&#x27;right&#x27;: &#x27;selectNodeRight&#x27;,
                        			&#x27;shift+right&#x27;: &#x27;activateNodeRight&#x27;,
                        			&#x27;shift+left&#x27;: &#x27;activateNodeLeft&#x27;,
                        			&#x27;meta+right ctrl+right meta+left ctrl+left&#x27;: &#x27;flip&#x27;,
                        			&#x27;shift+up&#x27;: &#x27;activateNodeUp&#x27;,
                        			&#x27;shift+down&#x27;: &#x27;activateNodeDown&#x27;,
                        			&#x27;down&#x27;: &#x27;selectNodeDown&#x27;,
                        			&#x27;space f2&#x27;: &#x27;editNode&#x27;,
                        			&#x27;f&#x27;: &#x27;toggleCollapse&#x27;,
                        			&#x27;c meta+x ctrl+x&#x27;: &#x27;cut&#x27;,
                        			&#x27;p meta+v ctrl+v&#x27;: &#x27;paste&#x27;,
                        			&#x27;y meta+c ctrl+c&#x27;: &#x27;copy&#x27;,
                        			&#x27;u meta+z ctrl+z&#x27;: &#x27;undo&#x27;,
                        			&#x27;shift+tab&#x27;: &#x27;insertIntermediate&#x27;,
                        			&#x27;Esc 0 meta+0 ctrl+0&#x27;: &#x27;resetView&#x27;,
                        			&#x27;r meta+shift+z ctrl+shift+z meta+y ctrl+y&#x27;: &#x27;redo&#x27;,
                        			&#x27;meta+plus ctrl+plus z&#x27;: &#x27;scaleUp&#x27;,
                        			&#x27;meta+minus ctrl+minus shift+z&#x27;: &#x27;scaleDown&#x27;,
                        			&#x27;meta+up ctrl+up&#x27;: &#x27;moveUp&#x27;,
                        			&#x27;meta+down ctrl+down&#x27;: &#x27;moveDown&#x27;,
                        			&#x27;ctrl+shift+v meta+shift+v&#x27;: &#x27;pasteStyle&#x27;,
                        			&#x27;Esc&#x27;: &#x27;cancelCurrentAction&#x27;
                        		},
                        		charEventHandlers = {
                        			&#x27;[&#x27; : &#x27;activateChildren&#x27;,
                        			&#x27;{&#x27;	: &#x27;activateNodeAndChildren&#x27;,
                        			&#x27;=&#x27;	: &#x27;activateSiblingNodes&#x27;,
                        			&#x27;.&#x27;	: &#x27;activateSelectedNode&#x27;,
                        			&#x27;/&#x27; : &#x27;toggleCollapse&#x27;,
                        			&#x27;a&#x27; : &#x27;openAttachment&#x27;,
                        			&#x27;i&#x27; : &#x27;editIcon&#x27;
                        		},
                        		actOnKeys = true,
                        		self = this;
                        	mapModel.addEventListener(&#x27;inputEnabledChanged&#x27;, function (canInput, holdFocus) {
                        		actOnKeys = canInput;
                        		if (canInput &amp;&amp; !holdFocus) {
                        			self.focus();
                        		}
                        	});
                        
                        
                        
                        	return this.each(function () {
                        		var element = $(this),
                        			stage = $(&#x27;&lt;div&gt;&#x27;).css({
                        				position: &#x27;relative&#x27;
                        			}).attr(&#x27;data-mapjs-role&#x27;, &#x27;stage&#x27;).appendTo(element).data({
                        				&#x27;offsetX&#x27;: element.innerWidth() / 2,
                        				&#x27;offsetY&#x27;: element.innerHeight() / 2,
                        				&#x27;width&#x27;: element.innerWidth() - 20,
                        				&#x27;height&#x27;: element.innerHeight() - 20,
                        				&#x27;scale&#x27;: 1
                        			}).updateStage(),
                        			previousPinchScale = false;
                        		element.css(&#x27;overflow&#x27;, &#x27;auto&#x27;).attr(&#x27;tabindex&#x27;, 1);
                        		if (mapModel.isEditingEnabled()) {
                        			(dragContainer || element).simpleDraggableContainer();
                        		}
                        
                        		if (!touchEnabled) {
                        			element.scrollWhenDragging(mapModel.getInputEnabled); //no need to do this for touch, this is native
                        			element.on(&#x27;mousedown&#x27;, function (e) {
                        				if (e.target !== element[0]) {
                        					element.css(&#x27;overflow&#x27;, &#x27;hidden&#x27;);
                        				}
                        			});
                        			jQuery(document).on(&#x27;mouseup&#x27;, function () {
                        				if (element.css(&#x27;overflow&#x27;) !== &#x27;auto&#x27;) {
                        					element.css(&#x27;overflow&#x27;, &#x27;auto&#x27;);
                        				}
                        			});
                        			element.imageDropWidget(imageInsertController);
                        		} else {
                        			element.on(&#x27;doubletap&#x27;, function (event) {
                        				mapModel.dispatchEvent(&#x27;contextMenuRequested&#x27;, mapModel.getCurrentlySelectedIdeaId(), event.gesture.center.pageX, event.gesture.center.pageY);
                        				event.preventDefault();
                        				event.gesture.preventDefault();
                        				return false;
                        			}).on(&#x27;pinch&#x27;, function (event) {
                        				if (!event || !event.gesture || !event.gesture.scale) {
                        					return;
                        				}
                        				var scale = event.gesture.scale;
                        				if (previousPinchScale) {
                        					scale = scale / previousPinchScale;
                        				}
                        				if (Math.abs(scale - 1) &lt; 0.05) {
                        					return;
                        				}
                        				previousPinchScale = event.gesture.scale;
                        
                        				mapModel.scale(&#x27;touch&#x27;, scale, {
                        					x: event.gesture.center.pageX - stage.data(&#x27;offsetX&#x27;),
                        					y: event.gesture.center.pageY - stage.data(&#x27;offsetY&#x27;)
                        				});
                        			}).on(&#x27;gestureend&#x27;, function () {
                        				previousPinchScale = false;
                        			});
                        
                        		}
                        		MAPJS.DOMRender.viewController(mapModel, stage, touchEnabled, imageInsertController, resourceTranslator);
                        		_.each(hotkeyEventHandlers, function (mappedFunction, keysPressed) {
                        			element.keydown(keysPressed, function (event) {
                        				if (actOnKeys) {
                        					event.stopImmediatePropagation();
                        					event.preventDefault();
                        					mapModel[mappedFunction](&#x27;keyboard&#x27;);
                        				}
                        			});
                        		});
                        		if (!touchEnabled) {
                        			jQuery(window).on(&#x27;resize&#x27;, function () {
                        				mapModel.resetView();
                        			});
                        		}
                        
                        		jQuery(window).on(&#x27;orientationchange&#x27;, function () {
                        			if (centerSelectedNodeOnOrientationChange) {
                        				mapModel.centerOnNode(mapModel.getSelectedNodeId());
                        			} else {
                        				mapModel.resetView();
                        			}
                        
                        		});
                        		jQuery(document).on(&#x27;keydown&#x27;, function (e) {
                        			var functions = {
                        				&#x27;U+003D&#x27;: &#x27;scaleUp&#x27;,
                        				&#x27;U+002D&#x27;: &#x27;scaleDown&#x27;,
                        				61: &#x27;scaleUp&#x27;,
                        				173: &#x27;scaleDown&#x27;
                        			}, mappedFunction;
                        			if (e &amp;&amp; !e.altKey &amp;&amp; (e.ctrlKey || e.metaKey)) {
                        				if (e.originalEvent &amp;&amp; e.originalEvent.keyIdentifier) { /* webkit */
                        					mappedFunction = functions[e.originalEvent.keyIdentifier];
                        				} else if (e.key === &#x27;MozPrintableKey&#x27;) {
                        					mappedFunction = functions[e.which];
                        				}
                        				if (mappedFunction) {
                        					if (actOnKeys) {
                        						e.preventDefault();
                        						mapModel[mappedFunction](&#x27;keyboard&#x27;);
                        					}
                        				}
                        			}
                        		}).on(&#x27;wheel mousewheel&#x27;, function (e) {
                        			var scroll = e.originalEvent.deltaX || (-1 * e.originalEvent.wheelDeltaX);
                        			if (scroll &lt; 0 &amp;&amp; element.scrollLeft() === 0) {
                        				e.preventDefault();
                        			}
                        			if (scroll &gt; 0 &amp;&amp; (element[0].scrollWidth - element.width() - element.scrollLeft() === 0)) {
                        				e.preventDefault();
                        			}
                        		});
                        
                        		element.on(&#x27;keypress&#x27;, function (evt) {
                        			if (!actOnKeys) {
                        				return;
                        			}
                        			if (/INPUT|TEXTAREA/.test(evt &amp;&amp; evt.target &amp;&amp; evt.target.tagName)) {
                        				return;
                        			}
                        			var unicode = evt.charCode || evt.keyCode,
                        				actualkey = String.fromCharCode(unicode),
                        				mappedFunction = charEventHandlers[actualkey];
                        			if (mappedFunction) {
                        				evt.preventDefault();
                        				mapModel[mappedFunction](&#x27;keyboard&#x27;);
                        			} else if (Number(actualkey) &lt;= 9 &amp;&amp; Number(actualkey) &gt;= 1) {
                        				evt.preventDefault();
                        				mapModel.activateLevel(&#x27;keyboard&#x27;, Number(actualkey) + 1);
                        			}
                        		});
                        	});
                        };
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
